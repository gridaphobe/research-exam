<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Eric Seidel" />
  <title>Automated Specification-Based Testing</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Automated Specification-Based Testing</h1>
  <p class="author">
Eric Seidel
  </p>
  <p class="date">eseidel@cs.ucsd.edu</p>
</div>
<div id="a-binary-search-tree-library" class="slide section level1">
<h1>A Binary Search Tree Library</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span>
  <span class="fu">=</span> <span class="dt">Leaf</span>
  <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span>

<span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span>
<span class="ot">delete ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></code></pre>
<div class="incremental">
<blockquote>
<p>Did I get it “right”?</p>
</blockquote>
</div>
</div>
<div id="testing" class="slide section level1">
<h1>Testing</h1>
<p>Two key questions to answer when testing:</p>
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?</li>
<li>How to <strong>check</strong> outputs?</li>
</ol>
<!-- # Outline -->
<!-- 1. **Human-generated tests** -->
<!-- 2. Machine-enumerated inputs -->
<!-- 3. Dynamic-Symbolic Execution -->
<!-- 4. Type-targeted testing -->
</div>
<div id="standard-practice" class="slide section level1">
<h1>Standard Practice</h1>
<p>Programmer specifies inputs <em>and</em> outputs</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">insert <span class="dv">1</span> <span class="dt">Leaf</span>
  <span class="fu">==</span> <span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>

insert <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)
  <span class="fu">==</span> <span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)</code></pre>
</div>
<div class="incremental">
<p>But this is tiresome…</p>
</div>
<div class="incremental">
<blockquote>
<p>hope that these tests generalize!</p>
</blockquote>
</div>
</div>
<div id="outline" class="slide section level1">
<h1>Outline</h1>
<!-- 1. Human-generated tests -->
<ol style="list-style-type: decimal">
<li><strong>Black-box testing</strong></li>
<li>White-box testing</li>
<li>Type-targeted testing</li>
</ol>
</div>
<div id="black-box-testing" class="slide section level1">
<h1>Black-box testing</h1>
<ul>
<li>Given a <em>specification</em> of expected behavior
<ul>
<li>but no knowledge of internals</li>
</ul></li>
<li>Generate many inputs and validate against spec</li>
</ul>
<!-- - Machine enumerates many inputs -->
<!-- - Programmer specifies oracle to check outputs -->
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_elem x t <span class="fu">=</span> x <span class="ot">`elem`</span> insert x t
prop_insert_bst  x t <span class="fu">=</span> isBST (insert x t)</code></pre>
</div>
</div>
<div id="enumerate-all-small-inputs" class="slide section level1">
<h1>Enumerate All “Small” Inputs</h1>
<p>“Small-scope hypothesis”</p>
<blockquote>
<p>if a counterexample exists, a “small” counterexample probably exists too</p>
</blockquote>
<ul>
<li>TestEra (2001), Korat (2004), SmallCheck (2008)</li>
</ul>
</div>
<div id="smallcheck" class="slide section level1">
<h1>SmallCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span>
  <span class="fu">=</span> <span class="dt">Leaf</span>
  <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span>

<span class="kw">instance</span> <span class="dt">Serial</span> <span class="dt">Tree</span> <span class="kw">where</span>
  series <span class="fu">=</span> cons0 <span class="dt">Leaf</span> \<span class="fu">/</span> cons3 <span class="dt">Node</span></code></pre>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">3</span> prop_insert_bst
<span class="dt">Failed</span> test no<span class="fu">.</span> <span class="dv">4</span><span class="fu">.</span>
there exist <span class="dv">0</span>, <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) such that
  condition is false</code></pre>
</div>
<div class="incremental">
<p><code>insert</code> doesn’t accept just <em>any</em> tree</p>
</div>
</div>
<div id="testing-insert-preconditions" class="slide section level1">
<h1>Testing <code>insert</code>: Preconditions</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t
  <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">3</span> prop_insert_bst
<span class="dt">Completed</span> <span class="dv">567</span> tests without failure<span class="fu">.</span>
<span class="dt">But</span> <span class="dv">434</span> did not meet <span class="fu">==&gt;</span> condition<span class="fu">.</span></code></pre>
</div>
</div>
<div id="how-small" class="slide section level1">
<h1>How small?</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">4</span> prop_insert_bst</code></pre>
</div>
<div id="how-small-1" class="slide section level1">
<h1>How small?</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">4</span> prop_insert_bst
<span class="fu">..........................................................</span></code></pre>
<div class="incremental">
<p>Exponential blowup in input space confines search to <em>very small</em> inputs!</p>
<!-- (Again, custom generators are a standard solution to increase feasible search depth) -->
</div>
<div class="incremental">
<ul>
<li>Can abuse laziness to filter equivalent inputs (Lazy SmallCheck, Korat)
<ul>
<li>but must be careful how you structure filtering predicate</li>
<li>e.g. should binary-search tree check ordering or balancing first?</li>
</ul></li>
</ul>
</div>
</div>
<div id="alternative-randomly-generate-inputs" class="slide section level1">
<h1>Alternative: Randomly Generate Inputs</h1>
<ul>
<li>random sampling from all possible inputs
<ul>
<li>enables checking larger inputs</li>
<li>no guarantee of minimal counterexample</li>
</ul></li>
<li>QuickCheck (2000), JCrasher (2004), Randoop (2007)</li>
</ul>
</div>
<div id="quickcheck" class="slide section level1">
<h1>QuickCheck</h1>
<ul>
<li>provides DSL for writing random value generators</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Tree</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> oneof [ leaf, node ]
    <span class="kw">where</span>
    leaf <span class="fu">=</span> return <span class="dt">Leaf</span>
    node <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> arbitrary
              l <span class="ot">&lt;-</span> arbitrary
              r <span class="ot">&lt;-</span> arbitrary
              return (<span class="dt">Node</span> x l r)</code></pre>
<ul>
<li>properties specified as with SmallCheck</li>
</ul>
</div>
<div id="testing-insert-quickcheck" class="slide section level1">
<h1>Testing <code>insert</code>: QuickCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre>
<div class="incremental">
<p>How is this possible? SmallCheck showed that input domain is <em>very</em> sparse!</p>
</div>
</div>
<div id="testing-insert-quickcheck-1" class="slide section level1">
<h1>Testing <code>insert</code>: QuickCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t
  <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> collect (size t) (isBST (insert x t))</code></pre>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">:</span>
<span class="dv">73</span><span class="fu">%</span> <span class="dv">0</span>
<span class="dv">21</span><span class="fu">%</span> <span class="dv">1</span>
 <span class="dv">6</span><span class="fu">%</span> <span class="dv">2</span></code></pre>
</div>
</div>
<div id="testing-insert-quickcheck-2" class="slide section level1">
<h1>Testing <code>insert</code>: QuickCheck</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst_nontrivial x t
  <span class="fu">=</span> isBST t <span class="fu">&amp;&amp;</span> size t <span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==&gt;</span> collect (size t) (isBST (insert x t))</code></pre>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst
<span class="fu">***</span> <span class="dt">Gave</span> up<span class="fu">!</span> <span class="dt">Passed</span> only <span class="dv">37</span> tests (<span class="dv">100</span><span class="fu">%</span> <span class="dv">2</span>)<span class="fu">.</span></code></pre>
</div>
<div class="incremental">
<p>Input domain is too sparse, QuickCheck cannot generate trees with more than 2 elements!</p>
</div>
</div>
<div id="testing-insert-custom-generators" class="slide section level1">
<h1>Testing <code>insert</code>: Custom Generators</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">BST</span> <span class="fu">=</span> <span class="dt">Tree</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">BST</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="fu">...</span>

prop_insert_bst x (<span class="dt">BST</span> xs)
  <span class="fu">=</span> isBST (insert x xs)</code></pre>
<div class="incremental">
<p>Must define a new type/generator for <em>each</em> precondition!</p>
</div>
</div>
<div id="recap" class="slide section level1">
<h1>Recap</h1>
<ul>
<li>brute-force enumeration of inputs suffers from input explosion</li>
<li>random generation enables testing larger inputs
<ul>
<li>sampling from a <strong>uniform</strong> distribution provides better case for generalizing outcome</li>
<li>but requires custom generators for preconditions</li>
</ul></li>
</ul>
</div>
<div id="outline-1" class="slide section level1">
<h1>Outline</h1>
<!-- 1. Human-generated tests -->
<ol style="list-style-type: decimal">
<li>Black-box testing</li>
<li><strong>White-box testing</strong></li>
<li>Type-targeted testing</li>
</ol>
</div>
<div id="white-box-testing" class="slide section level1">
<h1>White-Box Testing</h1>
<ul>
<li>Given program <em>implementation</em></li>
<li>Try to break it (i.e. make it crash) <!-- - Machine searches for inputs that violate it -->
<ul>
<li>avoid input explosion by enumerating program paths (via <strong>symbolic execution</strong>)</li>
<li>aim for 100% coverage as quickly as possible</li>
</ul></li>
</ul>
<!-- # Dynamic-Symbolic Testing -->
<!-- - introduced by Godefroid et al and Cadar et al in 2005 -->
<!-- - combines symbolic execution to enumerate code paths with concrete execution to trigger bugs -->
<!-- - search for inputs that make the program crash -->
</div>
<div id="a-primer-on-symbolic-execution" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> x <span class="fu">/</span> z
       <span class="kw">else</span> x</code></pre>
</div>
<div id="a-primer-on-symbolic-execution-1" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> x <span class="fu">/</span> z
       <span class="kw">else</span> x</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_0 = \{x \mapsto \alpha_1, y \mapsto \alpha_2\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_0 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="a-primer-on-symbolic-execution-2" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>    <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> x <span class="fu">/</span> z
       <span class="kw">else</span> x</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">↦</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_1 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_1 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="a-primer-on-symbolic-execution-3" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>    <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>      <span class="co">-- 2</span>
       <span class="kw">then</span> x <span class="fu">/</span> z
       <span class="kw">else</span> x</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">↦</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_2 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_2 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="a-primer-on-symbolic-execution-4" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>    <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>      <span class="co">-- 2</span>
       <span class="kw">then</span> x <span class="fu">/</span> z    <span class="co">-- 3</span>
       <span class="kw">else</span> x</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">↦</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_3 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_3 = \langle z &gt; 0 \rangle</annotation></semantics></math></p>
<div class="incremental">
<ul>
<li>Want to ensure <code>z!=0</code> to prevent divide-by-zero
<ul>
<li>conjoin with path condition to check feasibility of <strong>implicit</strong> branch</li>
</ul></li>
</ul>
</div>
<div class="incremental">
<p>Check:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>∧</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo>∧</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z = \alpha_2 + 1 \land z &gt; 0 \land z = 0</annotation></semantics></math></p>
</div>
</div>
<div id="a-primer-on-symbolic-execution-5" class="slide section level1">
<h1>A Primer on Symbolic Execution</h1>
<ul>
<li>originally envisioned as static-analysis technique</li>
<li>map variables to symbolic expressions instead of concrete values</li>
<li>construct <em>path condition</em> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>    <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>      <span class="co">-- 2</span>
       <span class="kw">then</span> x <span class="fu">/</span> z    <span class="co">-- 3</span>
       <span class="kw">else</span> x</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><msub><mi>α</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">↦</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_3 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_3 = \langle z &gt; 0 \rangle</annotation></semantics></math></p>
<ul>
<li>Want to ensure <code>z!=0</code> to prevent divide-by-zero
<ul>
<li>conjoin with path condition to check feasibility of <strong>implicit</strong> branch</li>
</ul></li>
</ul>
<p>Check:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><msub><mi>α</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>∧</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo>∧</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z = \alpha_2 + 1 \land z &gt; 0 \land z = 0</annotation></semantics></math>      <strong>UNSAT</strong></p>
<div class="incremental">
<p>Divide-by-zero is impossible!</p>
</div>
</div>
<div id="the-problem-with-symbolic-execution" class="slide section level1">
<h1>The Problem With Symbolic Execution</h1>
<ul>
<li>relies on constraint solver to reason about path feasibility</li>
<li>many programs are difficult to express in solver’s logic
<ul>
<li>non-linear arithmetic</li>
<li>floating-point numbers</li>
<li>pointer arithmetic</li>
</ul></li>
</ul>
</div>
<div id="dynamic-symbolic-testing" class="slide section level1">
<h1>Dynamic-Symbolic Testing</h1>
<ul>
<li>combine symbolic and concrete execution
<ul>
<li>fall back on <strong>concrete</strong> value when symbolic execution fails</li>
<li>DART (2005), CUTE (2006), EXE (2006), PEX (2008), KLEE (2008)</li>
</ul></li>
</ul>
</div>
<div id="dynamic-symbolic-testing-1" class="slide section level1">
<h1>Dynamic-Symbolic Testing</h1>
<ul>
<li>combine symbolic and concrete execution
<ul>
<li>fall back on <strong>concrete</strong> value when symbolic execution fails</li>
<li>DART (2005), CUTE (2006), EXE (2006), PEX (2008), KLEE (2008)</li>
</ul></li>
</ul>
<div class="incremental">
<ul>
<li>start with random inputs, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo accent="false">↦</mo><mstyle mathvariant="sans-serif"><mi>𝖭</mi><mi>𝗈</mi><mi>𝖽</mi><mi>𝖾</mi></mstyle><mspace width="0.222em"></mspace><mn>2</mn><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝖫</mi><mi>𝖾</mi><mi>𝖺</mi><mi>𝖿</mi></mstyle><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝖫</mi><mi>𝖾</mi><mi>𝖺</mi><mi>𝖿</mi></mstyle><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{x \mapsto 1, t \mapsto {\mathsf{{Node}}}\ 2\ {\mathsf{{Leaf}}}\ {\mathsf{{Leaf}}}\}</annotation></semantics></math></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">insert x t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> singleton x
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span> <span class="kw">case</span> compare x y <span class="kw">of</span>
    <span class="dt">LT</span> <span class="ot">-&gt;</span> bal y (insert x l) r
    <span class="dt">GT</span> <span class="ot">-&gt;</span> bal y l (insert x r)
    <span class="dt">EQ</span> <span class="ot">-&gt;</span> t</code></pre>
<ul class="incremental">
<li>at <code>LT</code> branch, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>L</mi><mi>T</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>t</mi><mo>=</mo><mstyle mathvariant="sans-serif"><mi>𝖭</mi><mi>𝗈</mi><mi>𝖽</mi><mi>𝖾</mi></mstyle><mspace width="0.222em"></mspace><mi>y</mi><mspace width="0.222em"></mspace><mi>l</mi><mspace width="0.222em"></mspace><mi>r</mi><mo>,</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">P_{LT} = \langle t = {\mathsf{{Node}}}\ y\ l\ r, x &lt; y \rangle</annotation></semantics></math></li>
<li>choose new path by negating path condition and solving for new inputs, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mstyle mathvariant="sans-serif"><mi>𝖭</mi><mi>𝗈</mi><mi>𝖽</mi><mi>𝖾</mi></mstyle><mspace width="0.222em"></mspace><mi>y</mi><mspace width="0.222em"></mspace><mi>l</mi><mspace width="0.222em"></mspace><mi>r</mi><mo>∧</mo><mo>¬</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">t = {\mathsf{{Node}}}\ y\ l\ r \land \lnot (x &lt; y)</annotation></semantics></math>
<ul class="incremental">
<li>(many more sophisticated search techniques have been explored)</li>
</ul></li>
</ul>
</div>
</div>
<div id="dynamic-symbolic-testing-specifications" class="slide section level1">
<h1>Dynamic-Symbolic Testing: Specifications</h1>
<ul>
<li><code>insert</code> will never crash on its own, need to check specification</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t <span class="fu">=</span> <span class="kw">do</span>
  assume (isBST t)
  <span class="kw">let</span> t&#39; <span class="fu">=</span> insert x t
  assert (isBST t&#39;)</code></pre>
<ul>
<li><code>assume</code> is a variant of <code>assert</code> that test-harness will not consider an error</li>
</ul>
<div class="incremental">
<p><strong>PROBLEM</strong>: paths must pass through <code>isBST</code> before reaching <code>insert</code>!</p>
</div>
</div>
<div id="dynamic-symbolic-testing-preconditions" class="slide section level1">
<h1>Dynamic-Symbolic Testing: Preconditions</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">isBST t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span> abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span>
             <span class="fu">&amp;&amp;</span> all (<span class="fu">&lt;</span> y) l <span class="fu">&amp;&amp;</span> all (<span class="fu">&gt;</span> y) r
             <span class="fu">&amp;&amp;</span> isBST l     <span class="fu">&amp;&amp;</span> isBST r</code></pre>
</div>
<div id="dynamic-symbolic-testing-preconditions-1" class="slide section level1">
<h1>Dynamic-Symbolic Testing: Preconditions</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">isBST t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span>
    <span class="fu">|</span> not (abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span>) <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (all (<span class="fu">&lt;</span> y) l)                    <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (all (<span class="fu">&gt;</span> y) r)                    <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (isBST l)                        <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (isBST r)                        <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> otherwise                            <span class="ot">-&gt;</span> <span class="dt">True</span></code></pre>
<div class="incremental">
<ul>
<li>5 possible paths for <em>invalid</em> node, only 1 for <em>valid</em> node
<ul>
<li>compounds as execution unfolds recursive datatype</li>
</ul></li>
</ul>
</div>
<div class="incremental">
<blockquote>
<p>executable specification causes solver to enumerate paths through <strong>precondition</strong> instead of function</p>
</blockquote>
</div>
</div>
<div id="recap-1" class="slide section level1">
<h1>Recap</h1>
<ul>
<li>dynamic-symbolic execution avoids input explosion by enumerating paths
<ul>
<li>can still suffer from <strong>path</strong> explosion</li>
<li>particularly when faced with recursive preconditions</li>
</ul></li>
</ul>
</div>
<div id="outline-2" class="slide section level1">
<h1>Outline</h1>
<!-- 1. Human-generated tests -->
<ol style="list-style-type: decimal">
<li>Black-box testing</li>
<li>White-box testing</li>
<li><strong>Type-targeted testing</strong></li>
</ol>
</div>
<div id="what-we-want" class="slide section level1">
<h1>What We Want</h1>
<!-- > Write a single generator per type, that can generate values satisfying different predicates. -->
<p>Systematically generate <strong>valid inputs</strong> that are <strong>guaranteed</strong> to pass the precondition</p>
<div class="incremental">
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?</li>
<li>How to <strong>check</strong> outputs?</li>
</ol>
<!-- # Type-Targeted Testing -->
</div>
<div class="incremental">
<p>Use <strong>refinement types</strong> as unified specification mechanism for input-generation and output-checking</p>
</div>
</div>
<div id="refinement-types" class="slide section level1">
<h1>Refinement Types</h1>
<h2 id="vt-p"><code>{v:t | p}</code></h2>
<blockquote>
<p>the set of values <code>v</code> of type <code>t</code> satisfying a predicate <code>p</code></p>
</blockquote>
</div>
<div id="simple-refinement-types" class="slide section level1">
<h1>Simple Refinement Types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Pos</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;</span>  <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Rng</span> <span class="dt">N</span> <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> v <span class="fu">&lt;</span> <span class="dt">N</span>}</code></pre>
</div>
<div id="compound-refinement-types" class="slide section level1">
<h1>Compound Refinement Types</h1>
<p>Describe properties of containers and function contracts by refining component types</p>
<h4 id="lists-that-contain-no-zeros">Lists that contain no zeros</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[{v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">/=</span> <span class="dv">0</span>}]</code></pre>
<h4 id="functions-that-take-a-natural-number-and-increment-it-by-one">Functions that take a natural number and increment it by one</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">x<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {v<span class="fu">:</span><span class="dt">Nat</span> <span class="fu">|</span> v <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>}</code></pre>
</div>
<div id="refinement-types-applications" class="slide section level1">
<h1>Refinement Types: Applications</h1>
<ul>
<li>Traditionally used for program verification</li>
<li>We show that refinement types can also be viewed as <em>exhaustive test-suite</em></li>
</ul>
<div class="incremental">
<h2 id="enables-gradual-verification">Enables <em>gradual verification</em></h2>
<ol style="list-style-type: decimal">
<li>write high-level spec as refinement type</li>
<li>immediate gratification from comprehensive test-suite</li>
<li>once design has settled, add hints / inductive invariants to allow verification</li>
</ol>
</div>
</div>
<div id="target" class="slide section level1">
<h1>Target</h1>
<ul>
<li>generates tests from refinement types via <em>query-decode-check</em> loop</li>
</ul>
<ol style="list-style-type: decimal">
<li>translate input types into SMT <strong>query</strong></li>
<li><strong>decode</strong> SMT model into concrete values</li>
<li>run function and <strong>check</strong> that result inhabits output type</li>
</ol>
<div class="incremental">
<ul>
<li>exhaustively checks all inputs up to a given depth-bound
<ul>
<li>like SmallCheck with a smarter generator</li>
</ul></li>
</ul>
</div>
</div>
<div id="primitive-types-query" class="slide section level1">
<h1>Primitive Types: Query</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<div class="incremental">
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-decode" class="slide section level1">
<h1>Primitive Types: Decode</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">↦</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 1, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span></code></pre>
</div>
<div id="primitive-types-check" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<ul class="incremental">
<li>Postcondition is:        <code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></li>
<li>After substitution:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 1</annotation></semantics></math></li>
</ul>
</div>
<div id="primitive-types-check-1" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<ul>
<li>Postcondition is:        <code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></li>
<li>After substitution:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 1</annotation></semantics></math>      <strong>VALID</strong></li>
</ul>
<div class="incremental">
<p>Request another model by <em>refuting</em> previous with</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mrow><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo>¬</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>∧</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>∧</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">{\mathsf{{C_1}}} {\ \doteq\ }{\mathsf{{C_0}}} {\ \land\ }\lnot ({\mathrm{{r_1}}} = 1 \land {\mathrm{{r_2}}} = 1 \land {\mathrm{{s}}} = 0)</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-next-model" class="slide section level1">
<h1>Primitive Types: Next model</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">↦</mo><mn>0</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">↦</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 0, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math></p>
<p>becomes</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<div class="incremental">
<p>After subsitution:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 0</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-next-model-1" class="slide section level1">
<h1>Primitive Types: Next model</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">↦</mo><mn>0</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">↦</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 0, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math></p>
<p>becomes</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>After subsitution:      <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 0</annotation></semantics></math>      <strong>INVALID</strong></p>
<p><code>rescale 1 0 0</code> is a counterexample!</p>
<!-- ```haskell -->
<!-- rescale :: r1:Pos -> r2:Pos -> s:Rng r1 -> Rng r2 -->
<!-- rescale r1 r2 s = s * (r2 `div` r1) -->
<!-- ``` -->
</div>
<div id="containers" class="slide section level1">
<h1>Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Weight</span> <span class="fu">=</span> <span class="dt">Pos</span>
<span class="kw">type</span> <span class="dt">Score</span>  <span class="fu">=</span> <span class="dt">Rng</span> <span class="dv">100</span>

<span class="ot">average ::</span> [(<span class="dt">Weight</span>, <span class="dt">Score</span>)] <span class="ot">-&gt;</span> <span class="dt">Score</span></code></pre>
<!-- average []  = 0 -->
<!-- average wxs = total `div` n -->
<!--   where -->
<!--     total   = sum [w * x | (w, x) <- wxs ] -->
<!--     n       = sum [w     | (w, _) <- wxs ] -->
<p>How to encode structured data in SMT formula?</p>
</div>
<div id="containers-query" class="slide section level1">
<h1>Containers: Query</h1>
<p>Generate a <em>single</em> set of constraints describing <em>all possible</em> inputs.</p>
<p><img height=400px src="skeleton.png"></p>
<p>Let solver choose path through skeleton.</p>
</div>
<div id="choice-variables" class="slide section level1">
<h1>Choice Variables</h1>
<p>Propositional variables that <em>guard</em> other constraints</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">({\mathrm{{c}}}_{00} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{[]}}) {\ \land\ }({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{{{\mathrm{{x}}}_1}:{{\mathrm{{xs}}}_1}}})</annotation></semantics></math></p>
<div class="incremental">
<p>Force solver to choose one with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo>⊕</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub></mrow><annotation encoding="application/x-tex">{\mathrm{{c}}}_{00} \oplus {\mathrm{{c}}}_{01}</annotation></semantics></math></p>
</div>
</div>
<div id="encoding-lists-of-depth-3" class="slide section level1">
<h1>Encoding Lists of Depth 3</h1>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗅</mi><mi>𝗂</mi><mi>𝗌</mi><mi>𝗍</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd></mtd><mtd></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{list}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{00} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{{{\mathrm{{x}}}_1}:{{\mathrm{{xs}}}_1}}}) &amp; {\ \land\ }&amp;  &amp; &amp; ({\mathrm{{c}}}_{00} &amp; \oplus &amp; {\mathrm{{c}}}_{01}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{10} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{{{\mathrm{{x}}}_2}:{{\mathrm{{xs}}}_2}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{10} &amp; \oplus &amp; {\mathrm{{c}}}_{11}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{20} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{{{\mathrm{{x}}}_3}:{{\mathrm{{xs}}}_3}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{20} &amp; \oplus &amp; {\mathrm{{c}}}_{21}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{30} \Rightarrow {\mathrm{{xs}}}_3 = {\mathrm{[]}}) &amp; &amp; &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{30}) &amp; &amp; \end{aligned}</annotation></semantics></math></p>
<div class="incremental">
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝖽</mi><mi>𝖺</mi><mi>𝗍</mi><mi>𝖺</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>1</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>1</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>2</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>2</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>3</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>3</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{data}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{x}}}_1 = {\mathrm{({{\mathrm{{w}}}_1},{{\mathrm{{s}}}_1})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_1 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_1 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{x}}}_2 = {\mathrm{({{\mathrm{{w}}}_2},{{\mathrm{{s}}}_2})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_2 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_2 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{x}}}_3 = {\mathrm{({{\mathrm{{w}}}_3},{{\mathrm{{s}}}_3})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_3 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_3 &lt; 100) \end{aligned}</annotation></semantics></math></p>
</div>
</div>
<div id="containers-decode" class="slide section level1">
<h1>Containers: Decode</h1>
<p>To build a list from a model</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝖿</mi><mi>𝖺</mi><mi>𝗅</mi><mi>𝗌</mi><mi>𝖾</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>2</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo>,</mo><mo>…</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[ {\mathrm{{c_{00}}}} \mapsto\ {{\mathsf{{false}}}},\ {\mathrm{{c_{01}}}} \mapsto\ {{\mathsf{{true}}}},\ {\mathrm{{w_1}}} \mapsto 1,\ {\mathrm{{s_1}}} \mapsto 2,\ {\mathrm{{c_{10}}}} \mapsto\ {{\mathsf{{true}}}}, \ldots\ ]</annotation></semantics></math></p>
<div class="incremental">
<p>follow the choice variables!</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>0</mn></mrow></msub></mstyle><mo accent="false">↦</mo><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo accent="false">⇒</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle></mrow><annotation encoding="application/x-tex">{\mathrm{{c_{i0}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{[]}}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></mstyle><mo accent="false">↦</mo><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo accent="false">⇒</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><mrow><mi>x</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mrow><annotation encoding="application/x-tex">{\mathrm{{c_{i1}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{{x_{i+1}}:{xs_{i+1}}}}</annotation></semantics></math></li>
</ul>
<p>Result:      <code>[(1,2)]</code></p>
</div>
</div>
<div id="refuting-containers" class="slide section level1">
<h1>Refuting Containers</h1>
<p>Key optimization</p>
<ul>
<li>refute only constraints that contribute to <em>realized</em> value</li>
</ul>
<div class="incremental">
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝖿</mi><mi>𝖺</mi><mi>𝗅</mi><mi>𝗌</mi><mi>𝖾</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo accent="false">↦</mo><mn>2</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo accent="false">↦</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo>,</mo><mo>…</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[ {\mathrm{{c_{00}}}} \mapsto\ {{\mathsf{{false}}}},\ {\mathrm{{c_{01}}}} \mapsto\ {{\mathsf{{true}}}},\ {\mathrm{{w_1}}} \mapsto 1,\ {\mathrm{{s_1}}} \mapsto 2,\ {\mathrm{{c_{10}}}} \mapsto\ {{\mathsf{{true}}}}, \ldots\ ]</annotation></semantics></math></p>
<p>is refuted by</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>𝖿</mi><mi>𝖺</mi><mi>𝗅</mi><mi>𝗌</mi><mi>𝖾</mi></mstyle><mo>∧</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo>∧</mo><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>∧</mo><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>2</mn><mo>∧</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>𝗍</mi><mi>𝗋</mi><mi>𝗎</mi><mi>𝖾</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lnot ({\mathrm{{c_{00}}}} = {{\mathsf{{false}}}}\land {\mathrm{{c_{01}}}} = {{\mathsf{{true}}}}\land {\mathrm{{w_1}}} = 1 \land {\mathrm{{s_1}}} = 2 \land {\mathrm{{c_{10}}}} = {{\mathsf{{true}}}})</annotation></semantics></math></p>
</div>
</div>
<div id="ordered-containers" class="slide section level1">
<h1>Ordered Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a

<span class="kw">data</span> <span class="dt">Sorted</span> a <span class="fu">=</span> []
              <span class="fu">|</span> (<span class="fu">:</span>) {<span class="ot"> h ::</span> a
                    ,<span class="ot"> t ::</span> <span class="dt">Sorted</span> {v<span class="fu">:</span>a <span class="fu">|</span> h <span class="fu">&lt;</span> v}
                    }</code></pre>
<p>Recursive refinement relates the <code>head</code> with <em>each</em> element of the <code>tail</code>.</p>
</div>
<div id="ordered-containers-query" class="slide section level1">
<h1>Ordered Containers: Query</h1>
<p>Instantiate recursive refinement each time we unfold <code>(:)</code></p>
<ul class="incremental">
<li>Level 2:      <code>x1 &lt; x2</code></li>
<li>Level 3:      <code>x1 &lt; x3 &amp;&amp; x2 &lt; x3</code></li>
</ul>
<div class="incremental">
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗈</mi><mi>𝗋</mi><mi>𝖽</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{ord}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2)  {\ \land\ }({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_3\ {\ \land\ }\ {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3) \end{aligned}</annotation></semantics></math></p>
</div>
</div>
<div id="aside-the-importance-of-guards" class="slide section level1">
<h1>Aside: The Importance of Guards</h1>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗈</mi><mi>𝗋</mi><mi>𝖽</mi><mo>′</mo></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{ord&#39;}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2)  {\ \land\ }({\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_3\ {\ \land\ }\ {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3) \end{aligned}</annotation></semantics></math></p>
<div class="incremental">
<p>forces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">{\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3</annotation></semantics></math> <em>regardless</em> of which are in the realized model!</p>
</div>
<div class="incremental">
<p>Prohibits generation of valid inputs, e.g. <code>[2,3]</code></p>
</div>
</div>
<div id="structured-containers" class="slide section level1">
<h1>Structured Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">best ::</span> k<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">&lt;=</span> len v} 
     <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">=</span> len v}

measure<span class="ot"> len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Nat</span>
len []      <span class="fu">=</span> <span class="dv">0</span>
len (x<span class="fu">:</span>xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</code></pre>
<!-- best k xs = take k $ reverse $ sort xs -->
</div>
<div id="structured-containers-query" class="slide section level1">
<h1>Structured Containers: Query</h1>
<p>Instantiate measure definition each time we unfold <code>[]</code> or <code>(:)</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗌</mi><mi>𝗂</mi><mi>𝗓</mi><mi>𝖾</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{size}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{00} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{0}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{0}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_1}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{10} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{1}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{1}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_2}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{20} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{2}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{2}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_3}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{30} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{3}}} = 0) &amp; &amp; \end{aligned}</annotation></semantics></math></p>
<div class="incremental">
<p>Enforce relation between <code>k</code> and <code>xs</code> by adding constraint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow></mrow><annotation encoding="application/x-tex">k \leq {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_0}}</annotation></semantics></math></p>
</div>
</div>
<div id="evaluation" class="slide section level1">
<h1>Evaluation</h1>
<ul>
<li>compared Target against QuickCheck, SmallCheck, Lazy SmallCheck
<ul>
<li><code>Data.Map</code>, <code>RBTree</code>, <code>XMonad.StackSet</code></li>
<li>no custom generators</li>
</ul></li>
<li><code>Data.Map</code>
<ul>
<li>checked balancing and ordering invariants</li>
</ul></li>
<li><code>RBTree</code>
<ul>
<li>checked red-black and ordering invariants</li>
</ul></li>
<li><code>XMonad.StackSet</code>
<ul>
<li>checked uniqueness of windows</li>
</ul></li>
</ul>
</div>
<div id="evaluation-1" class="slide section level1">
<h1>Evaluation</h1>
<p><img height=500px src="benchmarks.png"></p>
</div>
<div id="takeaway" class="slide section level1">
<h1>Takeaway</h1>
<ul class="incremental">
<li>Target can explore larger input spaces than (Lazy) SmallCheck</li>
<li>QuickCheck requires custom generators for functions with complex preconditions</li>
<li>Dynamic-symbolic testing gets stuck on precondition path-explosion</li>
<li>Target specs are amenable to future formal verification</li>
</ul>
</div>
<div id="backup-slides" class="slide section level1">
<h1>Backup Slides</h1>
</div>
<div id="dynamic-symbolic-testing-why-concrete-symbolic" class="slide section level1">
<h1>Dynamic-Symbolic Testing: Why Concrete + Symbolic?</h1>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> foo { <span class="dt">int</span> i; <span class="dt">char</span> c; }
bar (<span class="kw">struct</span> foo *a) {
  <span class="kw">if</span> (a-&gt;c == <span class="dv">0</span>) {
    *((<span class="dt">char</span> *)a + <span class="kw">sizeof</span>(<span class="dt">int</span>)) = <span class="dv">1</span>;
    <span class="kw">if</span> (a-&gt;c != <span class="dv">0</span>)
      abort();
  }
}</code></pre>
<ul class="incremental">
<li>Symbolic executors cannot report with <em>certainty</em> that <code>abort</code> is reachable
<ul class="incremental">
<li>pointer arithmetic confuses alias analysis</li>
</ul></li>
<li>Dynamic-Symbolic testing need only solve <code>a-&gt;c == 0</code> to produce <em>concrete</em> input that will blow up!
<ul class="incremental">
<li>fill gaps in symbolic reasoning with <strong>concrete</strong> value</li>
</ul></li>
</ul>
</div>
<div id="encoding-trees-of-depth-2" class="slide section level1">
<h1>Encoding Trees of Depth 2</h1>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗍</mi><mi>𝗋</mi><mi>𝖾</mi><mi>𝖾</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><mstyle mathvariant="normal"><mi>t</mi></mstyle><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>1</mn></mrow></msub><mo accent="false">⇒</mo><mstyle mathvariant="normal"><mi>t</mi></mstyle><mo>=</mo><mstyle mathvariant="normal"><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mi>t</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>t</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>t</mi></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd></mtd><mtd></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>0</mn></mrow></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>t</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>1</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>t</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mi>l</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>l</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>l</mi></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>0</mn></mrow></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>t</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>1</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>t</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mi>r</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>r</mi></msub><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>r</mi></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><mi>t</mi><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>0</mn></mrow></msub></mtd><mtd><mo>⊕</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>l</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>l</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>l</mi></msub><mn>0</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>l</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>l</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>t</mi></msub><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>l</mi></msub><mn>0</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>r</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>l</mi></mstyle><mi>r</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>l</mi><mi>r</mi></msub><mn>0</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>r</mi></msub><mn>0</mn></mrow></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="normal"><mi>r</mi></mstyle><mi>r</mi></msub><mo>=</mo><mstyle mathvariant="normal"><mi>L</mi><mi>e</mi><mi>a</mi><mi>f</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>t</mi></msub><mn>1</mn></mrow></msub></mtd><mtd><mo accent="false">⇒</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mrow><msub><mi>r</mi><mi>r</mi></msub><mn>0</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{tree}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{t0} \Rightarrow {\mathrm{{t}}} = {\mathrm{Leaf}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{t1} \Rightarrow {\mathrm{{t}}} = {\mathrm{Node\ {{\mathrm{{x}}}_t}\ {{\mathrm{{l}}}_t}\ {{\mathrm{{r}}}_t}}}) &amp; {\ \land\ }&amp;  &amp; &amp; ({\mathrm{{c}}}_{t0} &amp; \oplus &amp; {\mathrm{{c}}}_{t1}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{l_t0} \Rightarrow {\mathrm{{l}}}_t = {\mathrm{Leaf}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{l_t1} \Rightarrow {\mathrm{{l}}}_t = {\mathrm{Node\ {{\mathrm{{x}}}_l}\ {{\mathrm{{l}}}_l}\ {{\mathrm{{r}}}_l}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{l_t0} &amp; \oplus &amp; {\mathrm{{c}}}_{l_t1}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{r_t0} \Rightarrow {\mathrm{{r}}}_t = {\mathrm{Leaf}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{r_t1} \Rightarrow {\mathrm{{r}}}_t = {\mathrm{Node\ {{\mathrm{{x}}}_r}\ {{\mathrm{{l}}}_r}\ {{\mathrm{{r}}}_r}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{r_t0} &amp; \oplus &amp; {\mathrm{{c}}}_{r_t1}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{l_l0} \Rightarrow {\mathrm{{l}}}_l = {\mathrm{Leaf}}) &amp; &amp;  &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{l_t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{l_l0}) &amp; &amp; \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{r_l0} \Rightarrow {\mathrm{{r}}}_l = {\mathrm{Leaf}}) &amp; &amp;  &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{l_t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{r_l0}) &amp; &amp; \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{l_r0} \Rightarrow {\mathrm{{l}}}_r = {\mathrm{Leaf}}) &amp; &amp;  &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{r_t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{l_r0}) &amp; &amp; \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{r_r0} \Rightarrow {\mathrm{{r}}}_r = {\mathrm{Leaf}}) &amp; &amp;  &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{r_t1} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{r_r0}) &amp; &amp; \\ \end{aligned}</annotation></semantics></math></p>
</div>
<div id="notes" class="slide section level1">
<h1>NOTES</h1>
<ul>
<li>[ ] perhaps start with demo</li>
<li>[ ] intro is abrupt</li>
<li>[X] monomorphic tree</li>
<li>[ ] don’t show class isntances</li>
<li>[X] fix smallcheck/quickcheck examples</li>
<li>[ ] preface symbolic execution better (why?)</li>
<li>[X] keep rescale def around</li>
<li>[X] kill questions slide</li>
<li>[ ] maybe start with <code>average</code></li>
<li>[ ] more comparisons!!</li>
<li>[X] un-demorgan refutations</li>
<li>[X] clarify that we use a single set of constraints to represent all possible inputs</li>
</ul>
</div>
<div id="questions" class="slide section level1">
<h1>Questions</h1>
<ul>
<li>do we need base types in refinements (i.e. why not assertions?)
<ul>
<li>we use base types to implicitly quantify over elements of containers</li>
<li>avoid recursive assertions, which are difficult to reason about</li>
</ul></li>
<li>is theory of inductive datatypes decidable?
<ul>
<li>theory is decidable, but NP-complete</li>
<li>Arrays: QF is decidable (NP-complete), w/ quals undecidable</li>
<li>Integers: QF is NP-complete, w/ quals undecidable</li>
<li>contrast to QF_EUF, which is polynomial</li>
</ul></li>
<li>studies validating small-scope hypothesis?
<ul>
<li>2003 (unpublished) study of java collections framework claims validity</li>
</ul></li>
</ul>
</div>
</body>
</html>
