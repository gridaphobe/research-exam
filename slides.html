<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Eric Seidel" />
  <title>Automated Specification-Based Testing</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Automated Specification-Based Testing</h1>
  <p class="author">
Eric Seidel
  </p>
  <p class="date">eseidel@cs.ucsd.edu</p>
</div>
<div id="a-binary-search-tree-library" class="slide section level1">
<h1>A Binary Search Tree Library</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span>
  <span class="fu">=</span> <span class="dt">Leaf</span>
  <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span>
<span class="ot">delete ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></code></pre>
<div class="incremental">
<blockquote>
<p>Did I get it ‚Äúright‚Äù?</p>
</blockquote>
</div>
</div>
<div id="testing" class="slide section level1">
<h1>Testing</h1>
<p>Two key questions to answer when testing:</p>
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?</li>
<li>How to <strong>check</strong> outputs?</li>
</ol>
<!-- # Outline -->
<!-- 1. **Human-generated tests** -->
<!-- 2. Machine-enumerated inputs -->
<!-- 3. Dynamic-Symbolic Execution -->
<!-- 4. Type-targeted testing -->
</div>
<div id="standard-practice-unit-testing" class="slide section level1">
<h1>Standard Practice: Unit-Testing</h1>
<p>Programmer specifies inputs <em>and</em> outputs</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">assertEquals (insert <span class="dv">1</span> <span class="dt">Leaf</span>) (<span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)

assertEquals (insert <span class="dv">1</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>)) (<span class="dt">Node</span> <span class="dv">1</span> <span class="dt">Leaf</span> (<span class="dt">Node</span> <span class="dv">2</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>))</code></pre>
</div>
<div class="incremental">
<p>A lot of effort to produce a ‚Äúcomplete‚Äù test-suite!</p>
<!-- But this is tiresome... -->
<!-- . . . -->
<!-- > hope that these tests generalize! -->
</div>
</div>
<div id="this-talk" class="slide section level1">
<h1>This Talk</h1>
<h4 id="techniques-for-automatic-unit-testing">Techniques for Automatic Unit-Testing</h4>
<p>Existing Techniques</p>
<ol style="list-style-type: decimal">
<li><strong>Black-box testing</strong></li>
<li>White-box testing</li>
</ol>
<p>Our contribution</p>
<ol start="3" style="list-style-type: decimal">
<li>Type-targeted testing</li>
</ol>
</div>
<div id="black-box-testing" class="slide section level1">
<h1>Black-box testing</h1>
<p>Given a <strong>specification</strong> of expected behavior, but no knowledge of internals, generate many inputs and validate against spec</p>
<div class="incremental">
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?
<ul>
<li>Machine enumerates based on <strong>specification</strong></li>
</ul></li>
<li>How to <strong>check</strong> outputs?
<ul>
<li>Programmer supplies <strong>oracle</strong></li>
</ul></li>
</ol>
<!-- . . . -->
<!-- 1 is harder, start with 2 -->
<!-- - Machine enumerates many inputs -->
<!-- - Programmer specifies oracle to check outputs -->
<!-- . . . -->
<!-- MOVE THIS LATER, SHOW iSBST -->
<!-- ```haskell -->
<!-- prop_insert_elem x t = x `elem` insert x t -->
<!-- prop_insert_bst  x t = isBST (insert x t) -->
<!-- ``` -->
</div>
</div>
<div id="checking-outputs-with-oracles" class="slide section level1">
<h1>Checking Outputs with Oracles</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">isBST t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span> abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span>
             <span class="fu">&amp;&amp;</span> all (<span class="fu">&lt;</span> y) l <span class="fu">&amp;&amp;</span> all (<span class="fu">&gt;</span> y) r
             <span class="fu">&amp;&amp;</span> isBST l     <span class="fu">&amp;&amp;</span> isBST r</code></pre>
<p><code>isBST</code> <strong>checks</strong> whether a tree satisfies the balancing and ordering invariants</p>
</div>
<div id="providing-inputs-by-enumeration" class="slide section level1">
<h1>Providing Inputs by Enumeration</h1>
<p><strong>Small-scope hypothesis</strong>: if a counterexample exists, a ‚Äúsmall‚Äù counterexample probably exists too</p>
<ul>
<li>TestEra (2001), Korat (2004), SmallCheck (2008)</li>
</ul>
</div>
<div id="smallcheck" class="slide section level1">
<h1>SmallCheck</h1>
<!-- ```haskell -->
<!-- data Tree -->
<!--   = Leaf -->
<!--   | Node Int Tree Tree -->
<!-- instance Serial Tree where -->
<!--   series = cons0 Leaf \/ cons3 Node -->
<!-- ``` -->
<!-- . . . -->
<!-- ENUMERAUTE ALL SMALL INPUTS -->
<p>Given a <strong>property</strong>, SmallCheck enumerates all inputs (up to some depth) and runs the property</p>
<!-- WHAT ARE INPUTS AND OUTPUTS -->
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_insert_bst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_insert_bst x t <span class="fu">=</span> isBST (insert x t)</code></pre>
<p><code>prop_insert_bst</code> states that <code>insert</code> should return a <strong>valid</strong> tree</p>
</div>
<div class="incremental">
<!-- HOW TO RUN IT -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">3</span> prop_insert_bst</code></pre>
<p>Test all integers in range <code>[-3,3]</code> and all trees of depth 3</p>
</div>
<div class="incremental">
<!-- WHAT IS OUTPUT -->
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Failed</span> test no<span class="fu">.</span> <span class="dv">4</span><span class="fu">.</span>
there exist <span class="dv">0</span>, <span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> (<span class="dt">Node</span> <span class="dv">0</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) such that
  condition is false</code></pre>
<p>4th test produces <strong>invalid</strong> tree as output</p>
</div>
<div class="incremental">
<p>Property does not hold for <strong>all</strong> trees!</p>
</div>
</div>
<div id="smallcheck-adding-preconditions" class="slide section level1">
<h1>SmallCheck: Adding Preconditions</h1>
<p>Given a <strong>property</strong>, SmallCheck enumerates all inputs (up to some depth) and runs the property</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_insert_bst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_insert_bst x t <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<p><strong>If</strong> the input tree is valid, <strong>then</strong> the output tree should be valid</p>
<!-- HOW TO RUN IT -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">3</span> prop_insert_bst</code></pre>
<p>Test all integers in range <code>[-3,3]</code> and all trees of depth 3</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Completed</span> <span class="dv">567</span> tests without failure<span class="fu">.</span>
<span class="dt">But</span> <span class="dv">434</span> did not meet <span class="fu">==&gt;</span> condition<span class="fu">.</span></code></pre>
<p>Only 133 input trees were valid!</p>
</div>
</div>
<div id="smallcheck-how-small" class="slide section level1">
<h1>SmallCheck: How small?</h1>
<p>Given a <strong>property</strong>, SmallCheck enumerates all inputs (up to some depth) and runs the property</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_insert_bst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_insert_bst x t <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<p><strong>If</strong> the input tree is valid, <strong>then</strong> the output tree should be valid</p>
<!-- HOW TO RUN IT -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> smallCheck <span class="dv">4</span> prop_insert_bst</code></pre>
<p>Test all integers in range <code>[-4,4]</code> and all trees of depth 4</p>
<!-- # SmallCheck: How small? -->
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">..........................................................</span></code></pre>
</div>
<div class="incremental">
<p>Exponential blowup in input space confines search to <em>very small</em> inputs!</p>
<!-- (Again, custom generators are a standard solution to increase feasible search depth) -->
</div>
<div class="incremental">
<ul>
<li>Heuristics to prune ‚Äúequivalent‚Äù inputs (Lazy SmallCheck, Korat)</li>
<li>Can be brittle in practice <!-- - but must be careful how you structure precondition --> <!-- - e.g. should binary-search tree check ordering or balancing first? --></li>
</ul>
<!-- POP BACK TO BLACK-BOX, STRIKEOUT ALL, REPLACE WITH RANDOM -->
</div>
</div>
<div id="black-box-testing-1" class="slide section level1">
<h1>Black-box testing</h1>
<p>Given a <strong>specification</strong> of expected behavior, but no knowledge of internals, generate many inputs and validate against spec</p>
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?
<ul>
<li>Machine <strong>randomly</strong> enumerates based on <strong>specification</strong></li>
</ul></li>
<li>How to <strong>check</strong> outputs?
<ul>
<li>Programmer supplies <strong>oracle</strong></li>
</ul></li>
</ol>
</div>
<div id="providing-inputs-by-random-enumeration" class="slide section level1">
<h1>Providing Inputs by Random Enumeration</h1>
<ul>
<li>Sample random inputs from <strong>entire domain</strong></li>
<li>Enables checking larger inputs</li>
<li>No guarantee of minimal counterexample</li>
<li>QuickCheck (2000), JCrasher (2004), Randoop (2007)</li>
</ul>
<!-- # QuickCheck -->
<!-- - provides DSL for writing random value generators -->
<!-- <\!-- ```haskell -\-> -->
<!-- <\!-- instance Arbitrary Tree where -\-> -->
<!-- <\!--   arbitrary = oneof [ leaf, node ] -\-> -->
<!-- <\!--     where -\-> -->
<!-- <\!--     leaf = return Leaf -\-> -->
<!-- <\!--     node = do x <- arbitrary -\-> -->
<!-- <\!--               l <- arbitrary -\-> -->
<!-- <\!--               r <- arbitrary -\-> -->
<!-- <\!--               return (Node x l r) -\-> -->
<!-- <\!-- ``` -\-> -->
<!-- - properties specified as with SmallCheck -->
</div>
<div id="quickcheck" class="slide section level1">
<h1>QuickCheck</h1>
<p>Given a property, QuickCheck enumerates <strong>random</strong> inputs and runs the property</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t
  <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<p>If the input tree is valid, then the output tree should be valid</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst</code></pre>
<p>Test <code>prop_insert_bst</code> on 100 random, <strong>valid</strong> inputs</p>
</div>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre>
<p>How is this possible? SmallCheck showed that input domain is <em>very</em> sparse!</p>
</div>
</div>
<div id="quickcheck-with-statistics" class="slide section level1">
<h1>QuickCheck: With Statistics</h1>
<p>Given a property, QuickCheck enumerates <strong>random</strong> inputs and runs the property</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t
  <span class="fu">=</span> isBST t <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<p>If the input tree is valid, then the output tree should be valid</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst</code></pre>
<p>Test <code>prop_insert_bst</code> on 100 random, valid inputs, while collecting statistics about inputs</p>
<!-- # QuickCheck: Testing `insert` -->
<!-- ```haskell -->
<!-- prop_insert_bst x t -->
<!--   = isBST t ==> collect (size t) (isBST (insert x t)) -->
<!-- ``` -->
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">:</span>
<span class="dv">73</span><span class="fu">%</span> <span class="dv">0</span>
<span class="dv">21</span><span class="fu">%</span> <span class="dv">1</span>
 <span class="dv">6</span><span class="fu">%</span> <span class="dv">2</span></code></pre>
<p>73% of the trees were <strong>empty</strong> and 21% had only one element</p>
</div>
</div>
<div id="quickcheck-with-non-trivial-inputs" class="slide section level1">
<h1>QuickCheck: With Non-Trivial Inputs</h1>
<p>Given a property, QuickCheck enumerates <strong>random</strong> inputs and runs the property</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t
  <span class="fu">=</span> isBST t <span class="fu">&amp;&amp;</span> size t <span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">==&gt;</span> isBST (insert x t)</code></pre>
<p>If the input tree is valid <strong>and</strong> contains more than one element, then the output tree should be valid</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_bst</code></pre>
<p>Test <code>prop_insert_bst</code> on 100 random, valid inputs</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">***</span> <span class="dt">Gave</span> up<span class="fu">!</span> <span class="dt">Passed</span> only <span class="dv">37</span> tests<span class="fu">.</span></code></pre>
<p>Less than 1/10 generated trees were valid</p>
</div>
<div class="incremental">
<p>Input domain is too sparse, QuickCheck cannot generate trees with more than 2 elements!</p>
</div>
</div>
<div id="quickcheck-custom-generators" class="slide section level1">
<h1>QuickCheck: Custom Generators</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">BST</span> <span class="fu">=</span> <span class="dt">Tree</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">BST</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="fu">...</span>

prop_insert_bst x (<span class="dt">BST</span> xs)
  <span class="fu">=</span> isBST (insert x xs)</code></pre>
<div class="incremental">
<p><strong>Problem</strong></p>
<ol style="list-style-type: decimal">
<li>How to generate random <strong>valid</strong> trees?</li>
<li>Are we sampling from uniform distribution?</li>
<li>Must define a new type/generator for <strong>each</strong> precondition!</li>
</ol>
</div>
</div>
<div id="black-box-testing-2" class="slide section level1">
<h1>Black-box testing</h1>
<p>Given a specification of expected behavior, but no knowledge of internals, generate many inputs and validate against spec</p>
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?
<ul>
<li>Machine (randomly) enumerates based on <strong>specification</strong></li>
</ul></li>
<li>How to <strong>check</strong> outputs?
<ul>
<li>Programmer supplies <strong>oracle</strong></li>
</ul></li>
</ol>
</div>
<div id="black-box-testing-3" class="slide section level1">
<h1>Black-box testing</h1>
<p>Given a specification of expected behavior, but no knowledge of internals, generate many inputs and validate against spec</p>
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?
<ul>
<li>Machine (randomly) enumerates based on <strong>specification</strong></li>
</ul></li>
<li>How to <strong>check</strong> outputs?
<ul>
<li>Programmer supplies <strong>oracle</strong></li>
</ul></li>
</ol>
<h2 id="problems">Problems</h2>
<ul>
<li>Brute-force enumeration of inputs suffers from input explosion <!-- - Random generation enables testing larger inputs --> <!-- - Sampling from a **uniform** distribution provides better case for generalizing outcome --></li>
<li>Random enumeration requires custom generators for preconditions</li>
</ul>
</div>
<div id="this-talk-1" class="slide section level1">
<h1>This Talk</h1>
<h4 id="techniques-for-automatic-unit-testing-1">Techniques for Automatic Unit-Testing</h4>
<p>Existing Techniques</p>
<ol style="list-style-type: decimal">
<li>Black-box testing</li>
<li><strong>White-box testing</strong></li>
</ol>
<p>Our contribution</p>
<ol start="3" style="list-style-type: decimal">
<li>Type-targeted testing</li>
</ol>
</div>
<div id="white-box-testing" class="slide section level1">
<h1>White-Box Testing</h1>
<ul>
<li>Given program <strong>implementation</strong>, make it <strong>crash</strong></li>
<li>Enumerating program paths instead of inputs</li>
<li><strong>Symbolic execution</strong> groups equivalent inputs <!-- - aim for 100% coverage as quickly as possible --></li>
</ul>
<!-- # Dynamic-Symbolic Testing -->
<!-- - introduced by Godefroid et al and Cadar et al in 2005 -->
<!-- - combines symbolic execution to enumerate code paths with concrete execution to trigger bugs -->
<!-- - search for inputs that make the program crash -->
</div>
<div id="white-box-testing-via-symbolic-execution" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>)
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
</div>
<div id="white-box-testing-via-symbolic-execution-1" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                     <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>)
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_0 = \{x \mapsto \alpha_1, y \mapsto \alpha_2\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_0 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="white-box-testing-via-symbolic-execution-2" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                     <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>         <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>)
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">‚Ü¶</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_1 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_1 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="white-box-testing-via-symbolic-execution-3" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                     <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>         <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>           <span class="co">-- 2</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>)
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">‚Ü¶</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_2 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_2 = \langle \rangle</annotation></semantics></math></p>
</div>
<div id="white-box-testing-via-symbolic-execution-4" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                     <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>         <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>           <span class="co">-- 2</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>) <span class="co">-- 3</span>
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">‚Ü¶</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_3 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_3 = \langle z &gt; 0 \rangle</annotation></semantics></math></p>
<div class="incremental">
<p><strong>Implicit</strong> branch condition <code>z==0</code> would trigger assertion failure</p>
</div>
<div class="incremental">
<p>Check satisfiability of:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>‚àß</mo><msub><mi>P</mi><mn>3</mn></msub><mo>‚àß</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M_3 \land P_3 \land z = 0</annotation></semantics></math></p>
</div>
</div>
<div id="white-box-testing-via-symbolic-execution-5" class="slide section level1">
<h1>White-Box Testing Via Symbolic Execution</h1>
<ul>
<li>Originally envisioned as static-analysis technique</li>
<li>Program memory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> maps variables to symbolic expressions</li>
<li>Construct <strong>path condition</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> describing constraints to trigger current path</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y                     <span class="co">-- 0</span>
  <span class="fu">=</span> <span class="kw">let</span> z <span class="fu">=</span> y <span class="fu">+</span> <span class="dv">1</span>         <span class="co">-- 1</span>
    <span class="kw">in</span> <span class="kw">if</span> z <span class="fu">&gt;</span> <span class="dv">0</span>           <span class="co">-- 2</span>
       <span class="kw">then</span> assert (z<span class="fu">!=</span><span class="dv">0</span>) <span class="co">-- 3</span>
       <span class="kw">else</span> <span class="dt">True</span></code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo accent="false">‚Ü¶</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>,</mo><mi>z</mi><mo accent="false">‚Ü¶</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>Œ±</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">M_3 = \{x \mapsto \alpha_1, y \mapsto \alpha_2, z \mapsto (\alpha_2 + 1)\}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mi>z</mi><mo>&gt;</mo><mn>0</mn><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_3 = \langle z &gt; 0 \rangle</annotation></semantics></math></p>
<p><strong>Implicit</strong> branch condition <code>z==0</code> would trigger assertion failure</p>
<p>Check satisfiability of:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mn>3</mn></msub><mo>‚àß</mo><msub><mi>P</mi><mn>3</mn></msub><mo>‚àß</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">M_3 \land P_3 \land z = 0</annotation></semantics></math>¬†¬†¬†¬†¬†¬†<strong>UNSAT</strong></p>
<div class="incremental">
<p>Assertion cannot fail!</p>
</div>
</div>
<div id="the-problem-with-symbolic-execution" class="slide section level1">
<h1>The Problem With Symbolic Execution</h1>
<ol style="list-style-type: decimal">
<li>Relies on constraint solver to reason about path feasibility
<ul>
<li>Many programs are difficult to express in solver‚Äôs logic</li>
</ul></li>
<li>Path-explosion on real-world programs</li>
</ol>
</div>
<div id="dynamic-symbolic-execution" class="slide section level1">
<h1>Dynamic-Symbolic Execution</h1>
<ul>
<li>Combine symbolic and concrete execution</li>
<li>Fall back on <strong>concrete</strong> value when symbolic execution fails</li>
<li>DART (2005), CUTE (2006), EXE (2006), PEX (2008), KLEE (2008)</li>
</ul>
</div>
<div id="dynamic-symbolic-execution-1" class="slide section level1">
<h1>Dynamic-Symbolic Execution</h1>
<ul>
<li>Combine symbolic and concrete execution</li>
<li>Fall back on <strong>concrete</strong> value when symbolic execution fails</li>
<li>DART (2005), CUTE (2006), EXE (2006), PEX (2008), KLEE (2008)</li>
<li>Start with random inputs, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>t</mi><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùñ≠</mi><mi>ùóà</mi><mi>ùñΩ</mi><mi>ùñæ</mi></mstyle><mspace width="0.222em"></mspace><mn>2</mn><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùñ´</mi><mi>ùñæ</mi><mi>ùñ∫</mi><mi>ùñø</mi></mstyle><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùñ´</mi><mi>ùñæ</mi><mi>ùñ∫</mi><mi>ùñø</mi></mstyle><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{x = 1, t = {\mathsf{{Node}}}\ 2\ {\mathsf{{Leaf}}}\ {\mathsf{{Leaf}}}\}</annotation></semantics></math></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">insert x t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span>       <span class="ot">-&gt;</span> singleton x
  <span class="dt">Node</span> y l r
    <span class="fu">|</span> x <span class="fu">&lt;</span>  y <span class="ot">-&gt;</span> bal y (insert x l) r
    <span class="fu">|</span> x <span class="fu">&gt;</span>  y <span class="ot">-&gt;</span> bal y l (insert x r)
    <span class="fu">|</span> x <span class="fu">==</span> y <span class="ot">-&gt;</span> t</code></pre>
<ul class="incremental">
<li>At <code>LT</code> branch, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>L</mi><mi>T</mi></mrow></msub><mo>=</mo><mo stretchy="false" form="prefix">‚ü®</mo><mi>t</mi><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùñ≠</mi><mi>ùóà</mi><mi>ùñΩ</mi><mi>ùñæ</mi></mstyle><mspace width="0.222em"></mspace><mi>y</mi><mspace width="0.222em"></mspace><mi>l</mi><mspace width="0.222em"></mspace><mi>r</mi><mo>,</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo stretchy="false" form="postfix">‚ü©</mo></mrow><annotation encoding="application/x-tex">P_{LT} = \langle t = {\mathsf{{Node}}}\ y\ l\ r, x &lt; y \rangle</annotation></semantics></math></li>
<li>Choose new path by negating path condition and solving for new inputs, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùñ≠</mi><mi>ùóà</mi><mi>ùñΩ</mi><mi>ùñæ</mi></mstyle><mspace width="0.222em"></mspace><mi>y</mi><mspace width="0.222em"></mspace><mi>l</mi><mspace width="0.222em"></mspace><mi>r</mi><mo>‚àß</mo><mo>¬¨</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>&lt;</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">t = {\mathsf{{Node}}}\ y\ l\ r \land \lnot (x &lt; y)</annotation></semantics></math></li>
<li>Many more sophisticated search techniques have been explored</li>
</ul>
</div>
<div id="dynamic-symbolic-execution-specifications" class="slide section level1">
<h1>Dynamic-Symbolic Execution: Specifications</h1>
<p><code>insert</code> will never crash on its own, need to check specification</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">prop_insert_bst x t <span class="fu">=</span>
  <span class="kw">if</span> isBST t
  <span class="kw">then</span> assert (isBST (insert x t))
  <span class="kw">else</span> <span class="dt">True</span></code></pre>
<div class="incremental">
<p><strong>Problem</strong>: paths must pass through <code>isBST</code> before reaching <code>insert</code>!</p>
<!-- # Dynamic-Symbolic Execution: Preconditions -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">isBST t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span> abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span>
             <span class="fu">&amp;&amp;</span> all (<span class="fu">&lt;</span> y) l <span class="fu">&amp;&amp;</span> all (<span class="fu">&gt;</span> y) r
             <span class="fu">&amp;&amp;</span> isBST l     <span class="fu">&amp;&amp;</span> isBST r</code></pre>
</div>
</div>
<div id="dynamic-symbolic-execution-preconditions" class="slide section level1">
<h1>Dynamic-Symbolic Execution: Preconditions</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">isBST t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span>
  <span class="dt">Leaf</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
  <span class="dt">Node</span> y l r <span class="ot">-&gt;</span>
    <span class="fu">|</span> not (abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">1</span>) <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (all (<span class="fu">&lt;</span> y) l)                    <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (all (<span class="fu">&gt;</span> y) r)                    <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (isBST l)                        <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> not (isBST r)                        <span class="ot">-&gt;</span> <span class="dt">False</span>
    <span class="fu">|</span> otherwise                            <span class="ot">-&gt;</span> <span class="dt">True</span></code></pre>
<div class="incremental">
<ul>
<li>5 possible paths for <em>invalid</em> node, only 1 for <em>valid</em> node</li>
<li>Compounds as execution unfolds recursive datatype</li>
</ul>
</div>
<div class="incremental">
<blockquote>
<p>Solver enumerates paths through <strong>precondition</strong> instead of function</p>
</blockquote>
</div>
</div>
<div id="white-box-testing-1" class="slide section level1">
<h1>White-Box Testing</h1>
<ul>
<li>Given program <strong>implementation</strong>, make it <strong>crash</strong></li>
<li>Enumerating program paths instead of inputs</li>
<li><strong>Symbolic execution</strong> groups equivalent inputs</li>
</ul>
<div class="incremental">
<h2 id="problems-1">Problems</h2>
<ul>
<li>Symbolic execution suffers from inexpressive logics and path explosion</li>
<li>Dynamic-symbolic execution only addresses first issue</li>
<li>Path explosion particularly problematic when faced with recursive preconditions</li>
</ul>
</div>
</div>
<div id="this-talk-2" class="slide section level1">
<h1>This Talk</h1>
<h4 id="techniques-for-automatic-unit-testing-2">Techniques for Automatic Unit-Testing</h4>
<!-- 1. Human-generated tests -->
<p>Existing Techniques</p>
<ol style="list-style-type: decimal">
<li>Black-box testing</li>
<li>White-box testing</li>
</ol>
<p>Our contribution</p>
<ol start="3" style="list-style-type: decimal">
<li><strong>Type-targeted testing</strong></li>
</ol>
</div>
<div id="what-we-want" class="slide section level1">
<h1>What We Want</h1>
<!-- > Write a single generator per type, that can generate values satisfying different predicates. -->
<p>Systematically generate <strong>valid inputs</strong> that are <strong>guaranteed</strong> to pass the precondition</p>
<div class="incremental">
<ol style="list-style-type: decimal">
<li>How to <strong>provide</strong> inputs?</li>
<li>How to <strong>check</strong> outputs?</li>
</ol>
<!-- # Type-Targeted Testing -->
</div>
<div class="incremental">
<p>Use <strong>refinement types</strong> as unified specification mechanism for input-generation and output-checking</p>
</div>
</div>
<div id="refinement-types" class="slide section level1">
<h1>Refinement Types</h1>
<h2 id="vt-p"><code>{v:t | p}</code></h2>
<blockquote>
<p>The set of values <code>v</code> of type <code>t</code> satisfying a predicate <code>p</code></p>
</blockquote>
</div>
<div id="refinement-types-1" class="slide section level1">
<h1>Refinement Types</h1>
<h2 id="vt-p-1"><code>{v:t | p}</code></h2>
<blockquote>
<p>The set of values <code>v</code> of type <code>t</code> satisfying a predicate <code>p</code></p>
</blockquote>
<h3 id="simple-refinement-types">Simple Refinement Types</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Pos</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;</span>  <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Rng</span> <span class="dt">N</span> <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> v <span class="fu">&lt;</span> <span class="dt">N</span>}</code></pre>
<p>The natural numbers, positive integers, and integers in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,N)</annotation></semantics></math></p>
</div>
<div id="refinement-types-2" class="slide section level1">
<h1>Refinement Types</h1>
<h2 id="vt-p-2"><code>{v:t | p}</code></h2>
<blockquote>
<p>The set of values <code>v</code> of type <code>t</code> satisfying a predicate <code>p</code></p>
</blockquote>
<h3 id="simple-refinement-types-1">Simple Refinement Types</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Pos</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;</span>  <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Rng</span> <span class="dt">N</span> <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> v <span class="fu">&lt;</span> <span class="dt">N</span>}</code></pre>
<p>The natural numbers, positive integers, and integers in the range <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,N)</annotation></semantics></math></p>
<h3 id="compound-refinement-types">Compound Refinement Types</h3>
<p>Describe properties of containers and function contracts by refining component types</p>
<!-- ```haskell -->
<!-- [{v:Int | v /= 0}] -->
<!-- ``` -->
<!-- Lists that contain no zeros -->
<pre class="sourceCode haskell"><code class="sourceCode haskell">x<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {v<span class="fu">:</span><span class="dt">Nat</span> <span class="fu">|</span> v <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>}</code></pre>
<p>Functions that take a natural number and increment it by one</p>
</div>
<div id="refinement-types-applications" class="slide section level1">
<h1>Refinement Types: Applications</h1>
<p>Traditionally used for program verification</p>
<p>We show that refinement types can also be viewed as exhaustive test-suite</p>
<div class="incremental">
<h2 id="enables-gradual-verification">Enables gradual verification</h2>
<ol style="list-style-type: decimal">
<li>Write high-level spec as refinement type</li>
<li>Immediate gratification from comprehensive test-suite</li>
<li>Once design has settled, add hints / inductive invariants to allow verification</li>
</ol>
</div>
</div>
<div id="target" class="slide section level1">
<h1>Target</h1>
<p>Generates tests from refinement types via query-decode-check loop</p>
<ol style="list-style-type: decimal">
<li>Translate input types into SMT <strong>query</strong></li>
<li><strong>Decode</strong> SMT model into concrete values</li>
<li>Run function and <strong>check</strong> that result inhabits output type</li>
</ol>
<div class="incremental">
<p>Exhaustively checks all inputs up to a given depth-bound</p>
<blockquote>
<p>Like SmallCheck with a smarter generator</p>
</blockquote>
</div>
</div>
<div id="primitive-types-query" class="slide section level1">
<h1>Primitive Types: Query</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<div class="incremental">
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-decode" class="slide section level1">
<h1>Primitive Types: Decode</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 1, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span></code></pre>
</div>
<div id="primitive-types-check" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 1, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>Postcondition is:¬†¬†¬†¬†¬†¬†¬†¬†<code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></p>
</div>
<div id="primitive-types-check-1" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 1, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>Postcondition is:¬†¬†¬†¬†¬†¬†¬†¬†<code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></p>
<p>After substitution:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚â•</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 1</annotation></semantics></math></p>
</div>
<div id="primitive-types-check-2" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}}</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 1, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>Postcondition is:¬†¬†¬†¬†¬†¬†¬†¬†<code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></p>
<p>After substitution:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚â•</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 1</annotation></semantics></math>¬†¬†¬†¬†¬†¬†<strong>VALID</strong></p>
<div class="incremental">
<p>Request another model by <strong>refuting</strong> previous with</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo>¬¨</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">{\mathsf{{C_1}}} {\ \doteq\ }{\mathsf{{C_0}}} {\ \land\ }\lnot ({\mathrm{{r_1}}} = 1 \land {\mathrm{{r_2}}} = 1 \land {\mathrm{{s}}} = 0)</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-next-model" class="slide section level1">
<h1>Primitive Types: Next model</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo>¬¨</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">{\mathsf{{C_1}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}} {\ \land\ }\lnot ({\mathrm{{r_1}}} = 1 \land {\mathrm{{r_2}}} = 1 \land {\mathrm{{s}}} = 0)</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 0, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<div class="incremental">
<p>After subsitution:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚â•</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 0</annotation></semantics></math></p>
</div>
</div>
<div id="primitive-types-next-model-1" class="slide section level1">
<h1>Primitive Types: Next model</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>‚â§</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo>¬¨</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">{\mathsf{{C_1}}} {\ \doteq\ }0 \leq {\mathrm{{r_1}}} {\ \land\ }0 \leq {\mathrm{{r_2}}} {\ \land\ }0 \leq s &lt; {\mathrm{{r_1}}} {\ \land\ }\lnot ({\mathrm{{r_1}}} = 1 \land {\mathrm{{r_2}}} = 1 \land {\mathrm{{s}}} = 0)</annotation></semantics></math></p>
<p>A model <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="normal"><msub><mi>r</mi><mn>2</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo>,</mo><mstyle mathvariant="normal"><mi>s</mi></mstyle><mo accent="false">‚Ü¶</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathrm{{r_1}}} \mapsto 1, {\mathrm{{r_2}}} \mapsto 0, {\mathrm{{s}}} \mapsto 0]</annotation></semantics></math> maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>After subsitution:¬†¬†¬†¬†¬†¬†<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚â•</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 0</annotation></semantics></math>¬†¬†¬†¬†¬†¬†<strong>INVALID</strong></p>
<p><code>rescale 1 0 0</code> is a counterexample!</p>
<!-- ```haskell -->
<!-- rescale :: r1:Pos -> r2:Pos -> s:Rng r1 -> Rng r2 -->
<!-- rescale r1 r2 s = s * (r2 `div` r1) -->
<!-- ``` -->
</div>
<div id="containers" class="slide section level1">
<h1>Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Weight</span> <span class="fu">=</span> <span class="dt">Pos</span>
<span class="kw">type</span> <span class="dt">Score</span>  <span class="fu">=</span> <span class="dt">Rng</span> <span class="dv">100</span>
<span class="ot">average ::</span> [(<span class="dt">Weight</span>, <span class="dt">Score</span>)] <span class="ot">-&gt;</span> <span class="dt">Score</span></code></pre>
<p>How to encode structured data in SMT formula?</p>
</div>
<div id="containers-query" class="slide section level1">
<h1>Containers: Query</h1>
<p>Generate a <strong>single</strong> set of constraints describing <strong>all possible</strong> inputs.</p>
<p><img height=400px src="skeleton.png"></p>
<p>Let solver choose path through skeleton.</p>
</div>
<div id="containers-choice-variables" class="slide section level1">
<h1>Containers: Choice Variables</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Weight</span> <span class="fu">=</span> <span class="dt">Pos</span>
<span class="kw">type</span> <span class="dt">Score</span>  <span class="fu">=</span> <span class="dt">Rng</span> <span class="dv">100</span>
<span class="ot">average ::</span> [(<span class="dt">Weight</span>, <span class="dt">Score</span>)] <span class="ot">-&gt;</span> <span class="dt">Score</span></code></pre>
<p>How to encode structured data in SMT formula?</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">({\mathrm{{c}}}_{00} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{[]}}) {\ \land\ }({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{{{\mathrm{{x}}}_1}:{{\mathrm{{xs}}}_1}}})</annotation></semantics></math></p>
<p>Choice variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="normal"><mi>c</mi></mstyle><annotation encoding="application/x-tex">{\mathrm{{c}}}</annotation></semantics></math> <strong>guard</strong> other constraints</p>
<div class="incremental">
<p>Force solver to choose one with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo>‚äï</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub></mrow><annotation encoding="application/x-tex">{\mathrm{{c}}}_{00} \oplus {\mathrm{{c}}}_{01}</annotation></semantics></math></p>
</div>
</div>
<div id="containers-encoding-lists-of-depth-3" class="slide section level1">
<h1>Containers: Encoding Lists of Depth 3</h1>
<!-- $\begin{aligned} -->
<!-- \cstr{C_{list}} & \defeq & (\cvar{c}_{i0} \Rightarrow \cvar{xs}_i = \lnil) \wedge -->
<!--                            (\cvar{c}_{i1} \Rightarrow \cvar{xs}_i = \lcons{\cvar{x}_{i+1}}{\cvar{xs}_{i+1}})\\ -->
<!--                 & \wedge & (\cvar{c}_{i1} \Rightarrow \cvar{c}_{(i+1)0} \oplus \cvar{c}_{(i+1)1})\\ -->
<!-- \end{aligned}$ -->
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóÖ</mi><mi>ùóÇ</mi><mi>ùóå</mi><mi>ùóç</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd></mtd><mtd></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{list}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{00} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{{{\mathrm{{x}}}_1}:{{\mathrm{{xs}}}_1}}}) &amp; {\ \land\ }&amp;  &amp; &amp; ({\mathrm{{c}}}_{00} &amp; \oplus &amp; {\mathrm{{c}}}_{01}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{10} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{{{\mathrm{{x}}}_2}:{{\mathrm{{xs}}}_2}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{10} &amp; \oplus &amp; {\mathrm{{c}}}_{11}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{20} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{{{\mathrm{{x}}}_3}:{{\mathrm{{xs}}}_3}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{20} &amp; \oplus &amp; {\mathrm{{c}}}_{21}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{30} \Rightarrow {\mathrm{{xs}}}_3 = {\mathrm{[]}}) &amp; &amp; &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{30}) &amp; &amp; \end{aligned}</annotation></semantics></math></p>
<p>Encodes the <strong>structure</strong> of all lists with at most 3 elements.</p>
</div>
<div id="containers-encoding-lists-of-depth-3-1" class="slide section level1">
<h1>Containers: Encoding Lists of Depth 3</h1>
<!-- $\begin{aligned} -->
<!-- \cstr{C_{list}} & \defeq & (\cvar{c}_{i0} \Rightarrow \cvar{xs}_i = \lnil) \wedge -->
<!--                            (\cvar{c}_{i1} \Rightarrow \cvar{xs}_i = \lcons{\cvar{x}_{i+1}}{\cvar{xs}_{i+1}})\\ -->
<!--                 & \wedge & (\cvar{c}_{i1} \Rightarrow \cvar{c}_{(i+1)0} \oplus \cvar{c}_{(i+1)1})\\ -->
<!-- \end{aligned}$ -->
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóÖ</mi><mi>ùóÇ</mi><mi>ùóå</mi><mi>ùóç</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd></mtd><mtd></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo>:</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub></mtd><mtd><mo>‚äï</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub></mtd><mtd><mo accent="false">‚áí</mo></mtd><mtd><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{list}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{00} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{xs}}}_0 = {\mathrm{{{\mathrm{{x}}}_1}:{{\mathrm{{xs}}}_1}}}) &amp; {\ \land\ }&amp;  &amp; &amp; ({\mathrm{{c}}}_{00} &amp; \oplus &amp; {\mathrm{{c}}}_{01}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{10} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{xs}}}_1 = {\mathrm{{{\mathrm{{x}}}_2}:{{\mathrm{{xs}}}_2}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{10} &amp; \oplus &amp; {\mathrm{{c}}}_{11}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{20} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{xs}}}_2 = {\mathrm{{{\mathrm{{x}}}_3}:{{\mathrm{{xs}}}_3}}}) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{20} &amp; \oplus &amp; {\mathrm{{c}}}_{21}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{30} \Rightarrow {\mathrm{{xs}}}_3 = {\mathrm{[]}}) &amp; &amp; &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} &amp; \Rightarrow &amp; {\mathrm{{c}}}_{30}) &amp; &amp; \end{aligned}</annotation></semantics></math></p>
<p>Encodes the <strong>structure</strong> of all lists with at most 3 elements.</p>
<!-- $\cstr{C_{data}} \defeq \cvar{c}_{i1} \Rightarrow \cvar{x}_{i+1} = \ltup{\cvar{w}_{i+1}}{\cvar{s}_{i+1}} \ \wedge\ 0 < \cvar{w}_{i+1} \ \wedge\ 0 \leq \cvar{s}_{i+1} < 100$ -->
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùñΩ</mi><mi>ùñ∫</mi><mi>ùóç</mi><mi>ùñ∫</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>1</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>1</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>‚â§</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>2</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>2</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>‚â§</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>3</mn></msub><mo>,</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>w</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>‚â§</mo><msub><mstyle mathvariant="normal"><mi>s</mi></mstyle><mn>3</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{data}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{01} \Rightarrow {\mathrm{{x}}}_1 = {\mathrm{({{\mathrm{{w}}}_1},{{\mathrm{{s}}}_1})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_1 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_1 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{x}}}_2 = {\mathrm{({{\mathrm{{w}}}_2},{{\mathrm{{s}}}_2})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_2 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_2 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{x}}}_3 = {\mathrm{({{\mathrm{{w}}}_3},{{\mathrm{{s}}}_3})}} \ {\ \land\ }\ 0 &lt; {\mathrm{{w}}}_3 \ {\ \land\ }\ 0 \leq {\mathrm{{s}}}_3 &lt; 100) \end{aligned}</annotation></semantics></math></p>
<p>Encodes the constraints on the <strong>elements</strong> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóÖ</mi><mi>ùóÇ</mi><mi>ùóå</mi><mi>ùóç</mi></mrow></msub></mstyle><annotation encoding="application/x-tex">{\mathsf{{C_{list}}}}</annotation></semantics></math>.</p>
</div>
<div id="containers-decode" class="slide section level1">
<h1>Containers: Decode</h1>
<p>To build a list from a model</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùñø</mi><mi>ùñ∫</mi><mi>ùóÖ</mi><mi>ùóå</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>2</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mo>‚Ä¶</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[ {\mathrm{{c_{00}}}} \mapsto\ {{\mathsf{{false}}}},\ {\mathrm{{c_{01}}}} \mapsto\ {{\mathsf{{true}}}},\ {\mathrm{{w_1}}} \mapsto 1,\ {\mathrm{{s_1}}} \mapsto 2,\ {\mathrm{{c_{10}}}} \mapsto\ {{\mathsf{{true}}}}, \ldots\ ]</annotation></semantics></math></p>
<div class="incremental">
<p>follow the choice variables!</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>0</mn></mrow></msub></mstyle><mo accent="false">‚Ü¶</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo accent="false">‚áí</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></mstyle><mo accent="false">‚Ü¶</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo accent="false">‚áí</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><mrow><mi>x</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mrow><annotation encoding="application/x-tex">{\mathrm{{c_{i0}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{[]}}\ \land\ {\mathrm{{c_{i1}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{{x_{i+1}}:{xs_{i+1}}}}</annotation></semantics></math></p>
<p>Realized value:¬†¬†¬†¬†¬†¬†<code>[(1,2)]</code></p>
</div>
</div>
<div id="containers-refuting" class="slide section level1">
<h1>Containers: Refuting</h1>
<p>To build a list from a model</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùñø</mi><mi>ùñ∫</mi><mi>ùóÖ</mi><mi>ùóå</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>2</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mo>‚Ä¶</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[ {\mathrm{{c_{00}}}} \mapsto\ {{\mathsf{{false}}}},\ {\mathrm{{c_{01}}}} \mapsto\ {{\mathsf{{true}}}},\ {\mathrm{{w_1}}} \mapsto 1,\ {\mathrm{{s_1}}} \mapsto 2,\ {\mathrm{{c_{10}}}} \mapsto\ {{\mathsf{{true}}}}, \ldots\ ]</annotation></semantics></math></p>
<p>follow the choice variables!</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>0</mn></mrow></msub></mstyle><mo accent="false">‚Ü¶</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo accent="false">‚áí</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub></mstyle><mo accent="false">‚Ü¶</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo accent="false">‚áí</mo><mstyle mathvariant="normal"><mi>x</mi><msub><mi>s</mi><mi>i</mi></msub></mstyle><mo>=</mo><mstyle mathvariant="normal"><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><mrow><mi>x</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mstyle></mrow><annotation encoding="application/x-tex">{\mathrm{{c_{i0}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{[]}}\ \land\ {\mathrm{{c_{i1}}}} \mapsto {{\mathsf{{true}}}}{\Rightarrow}{\mathrm{{xs_i}}} = {\mathrm{{x_{i+1}}:{xs_{i+1}}}}</annotation></semantics></math></p>
<p>Realized value:¬†¬†¬†¬†¬†¬†<code>[(1,2)]</code></p>
<p><strong>Only</strong> refute constraints that contribute to <strong>realized</strong> value</p>
<div class="incremental">
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùñø</mi><mi>ùñ∫</mi><mi>ùóÖ</mi><mi>ùóå</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>1</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mn>2</mn><mo>,</mo><mspace width="0.222em"></mspace><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo accent="false">‚Ü¶</mo><mspace width="0.222em"></mspace><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>,</mo><mo>‚Ä¶</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[ {\mathrm{{c_{00}}}} \mapsto\ {{\mathsf{{false}}}},\ {\mathrm{{c_{01}}}} \mapsto\ {{\mathsf{{true}}}},\ {\mathrm{{w_1}}} \mapsto 1,\ {\mathrm{{s_1}}} \mapsto 2,\ {\mathrm{{c_{10}}}} \mapsto\ {{\mathsf{{true}}}}, \ldots\ ]</annotation></semantics></math></p>
<p>is refuted by</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬¨</mo><mo stretchy="false" form="prefix">(</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>00</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùñø</mi><mi>ùñ∫</mi><mi>ùóÖ</mi><mi>ùóå</mi><mi>ùñæ</mi></mstyle><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>01</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>w</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>1</mn><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>s</mi><mn>1</mn></msub></mstyle><mo>=</mo><mn>2</mn><mo>‚àß</mo><mstyle mathvariant="normal"><msub><mi>c</mi><mn>10</mn></msub></mstyle><mo>=</mo><mstyle mathvariant="sans-serif"><mi>ùóç</mi><mi>ùóã</mi><mi>ùóé</mi><mi>ùñæ</mi></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lnot ({\mathrm{{c_{00}}}} = {{\mathsf{{false}}}}\land {\mathrm{{c_{01}}}} = {{\mathsf{{true}}}}\land {\mathrm{{w_1}}} = 1 \land {\mathrm{{s_1}}} = 2 \land {\mathrm{{c_{10}}}} = {{\mathsf{{true}}}})</annotation></semantics></math></p>
</div>
</div>
<div id="ordered-containers" class="slide section level1">
<h1>Ordered Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sorted</span> a <span class="fu">=</span> []
              <span class="fu">|</span> (<span class="fu">:</span>) {<span class="ot"> h ::</span> a,<span class="ot"> t ::</span> <span class="dt">Sorted</span> {v<span class="fu">:</span>a <span class="fu">|</span> h <span class="fu">&lt;</span> v} }</code></pre>
<p>Recursive refinement relates the <code>head</code> with <strong>each</strong> element of the <code>tail</code>.</p>
</div>
<div id="ordered-containers-query" class="slide section level1">
<h1>Ordered Containers: Query</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sorted</span> a <span class="fu">=</span> []
              <span class="fu">|</span> (<span class="fu">:</span>) {<span class="ot"> h ::</span> a,<span class="ot"> t ::</span> <span class="dt">Sorted</span> {v<span class="fu">:</span>a <span class="fu">|</span> h <span class="fu">&lt;</span> v} }</code></pre>
<p>Recursive refinement relates the <code>head</code> with <strong>each</strong> element of the <code>tail</code>.</p>
<p>Instantiate recursive refinement each time we unfold <code>(:)</code></p>
<ul class="incremental">
<li>Level 2:¬†¬†¬†¬†¬†¬†<code>x1 &lt; x2</code></li>
<li>Level 3:¬†¬†¬†¬†¬†¬†<code>x1 &lt; x3 &amp;&amp; x2 &lt; x3</code></li>
</ul>
<div class="incremental">
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóà</mi><mi>ùóã</mi><mi>ùñΩ</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">‚áí</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{ord}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{11} \Rightarrow {\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2)  {\ \land\ }({\mathrm{{c}}}_{21} \Rightarrow {\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_3\ {\ \land\ }\ {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3) \end{aligned}</annotation></semantics></math></p>
</div>
</div>
<div id="ordered-containers-guards" class="slide section level1">
<h1>Ordered Containers: Guards</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sorted</span> a <span class="fu">=</span> []
              <span class="fu">|</span> (<span class="fu">:</span>) {<span class="ot"> h ::</span> a,<span class="ot"> t ::</span> <span class="dt">Sorted</span> {v<span class="fu">:</span>a <span class="fu">|</span> h <span class="fu">&lt;</span> v} }</code></pre>
<p>Recursive refinement relates the <code>head</code> with <strong>each</strong> element of the <code>tail</code>.</p>
<p>Instantiate recursive refinement each time we unfold <code>(:)</code></p>
<ul>
<li>Level 2:¬†¬†¬†¬†¬†¬†<code>x1 &lt; x2</code></li>
<li>Level 3:¬†¬†¬†¬†¬†¬†<code>x1 &lt; x3 &amp;&amp; x2 &lt; x3</code></li>
</ul>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóà</mi><mi>ùóã</mi><mi>ùñΩ</mi><mo>‚Ä≤</mo></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{ord&#39;}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2)  {\ \land\ }({\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_3\ {\ \land\ }\ {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3) \end{aligned}</annotation></semantics></math></p>
<div class="incremental">
<p>Forces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="normal"><mi>x</mi></mstyle><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">{\mathrm{{x}}}_1 &lt; {\mathrm{{x}}}_2 &lt; {\mathrm{{x}}}_3</annotation></semantics></math> <strong>regardless</strong> of which are in the realized model!</p>
</div>
<div class="incremental">
<p>Prohibits generation of valid inputs, e.g. <code>[2,3]</code></p>
</div>
</div>
<div id="structured-containers" class="slide section level1">
<h1>Structured Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">best ::</span> k<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {xs<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">&lt;=</span> len xs} <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">=</span> len v}</code></pre>
<p><code>best</code> takes a list of <strong>at least</strong> <code>k</code> scores, and returns a list with <strong>exactly</strong> <code>k</code> scores.</p>
<div class="incremental">
<pre class="sourceCode haskell"><code class="sourceCode haskell">measure<span class="ot"> len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Nat</span>
len []      <span class="fu">=</span> <span class="dv">0</span>
len (x<span class="fu">:</span>xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</code></pre>
<p><code>len</code> is a <strong>logical function</strong> that describes the length of a list.</p>
<!-- best k xs = take k $ reverse $ sort xs -->
</div>
</div>
<div id="structured-containers-query" class="slide section level1">
<h1>Structured Containers: Query</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">best ::</span> k<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {xs<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">&lt;=</span> len xs} <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">=</span> len v}</code></pre>
<p><code>best</code> takes a list of <strong>at least</strong> <code>k</code> scores, and returns a list with <strong>exactly</strong> <code>k</code> scores.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">measure<span class="ot"> len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Nat</span>
len []      <span class="fu">=</span> <span class="dv">0</span>
len (x<span class="fu">:</span>xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</code></pre>
<p><code>len</code> is a <strong>logical function</strong> that describes the length of a list.</p>
<p>Instantiate measure definition each time we unfold <code>[]</code> or <code>(:)</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>ùñ¢</mi><mrow><mi>ùóå</mi><mi>ùóÇ</mi><mi>ùóì</mi><mi>ùñæ</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚âê</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>00</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>01</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>10</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>11</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>20</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>21</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>‚àß</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="normal"><mi>c</mi></mstyle><mn>30</mn></msub><mo accent="false">‚áí</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>3</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{size}}}} &amp; {\ \doteq\ }&amp; ({\mathrm{{c}}}_{00} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{0}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{01} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{0}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_1}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{10} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{1}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{11} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{1}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_2}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{20} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{2}}} = 0) &amp; {\ \land\ }&amp;  ({\mathrm{{c}}}_{21} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{2}}} = 1 + {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_3}}) \\  &amp; {\ \land\ }&amp; ({\mathrm{{c}}}_{30} \Rightarrow {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_{3}}} = 0) &amp; &amp; \end{aligned}</annotation></semantics></math></p>
<div class="incremental">
<p>Enforce relation between <code>k</code> and <code>xs</code> by adding constraint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>‚â§</mo><mrow><mstyle mathvariant="sans-serif"><mi>ùóÖ</mi><mi>ùñæ</mi><mi>ùóá</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="normal"><mi>x</mi><mi>s</mi></mstyle><mn>0</mn></msub></mrow></mrow><annotation encoding="application/x-tex">k \leq {{\mathsf{{len}}}\ {{\mathrm{{xs}}}_0}}</annotation></semantics></math></p>
</div>
</div>
<div id="evaluation" class="slide section level1">
<h1>Evaluation</h1>
<ul>
<li>Compared Target against QuickCheck, SmallCheck, Lazy SmallCheck</li>
<li>Real libraries: <code>Data.Map</code>, <code>RBTree</code>, <code>XMonad.StackSet</code></li>
<li>No custom generators</li>
<li><code>Data.Map</code>: checked balancing and ordering invariants</li>
<li><code>RBTree</code>: checked red-black and ordering invariants</li>
<li><code>XMonad.StackSet</code>: checked uniqueness of windows</li>
</ul>
</div>
<div id="evaluation-1" class="slide section level1">
<h1>Evaluation</h1>
<p><img height=500px src="benchmarks.png"></p>
<p>Target can consistently check larger inputs than (Lazy) SmallCheck.</p>
</div>
<div id="takeaway" class="slide section level1">
<h1>Takeaway</h1>
<ul class="incremental">
<li>Target can explore larger input spaces than (Lazy) SmallCheck</li>
<li>QuickCheck requires custom generators for functions with complex preconditions</li>
<li>Dynamic-symbolic execution gets stuck on precondition path-explosion</li>
<li>Target specs are amenable to future formal verification</li>
</ul>
</div>
<div id="backup-slides" class="slide section level1">
<h1>Backup Slides</h1>
</div>
<div id="dynamic-symbolic-testing-why-concrete-symbolic" class="slide section level1">
<h1>Dynamic-Symbolic Testing: Why Concrete + Symbolic?</h1>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> foo { <span class="dt">int</span> i; <span class="dt">char</span> c; }
bar (<span class="kw">struct</span> foo *a) {
  <span class="kw">if</span> (a-&gt;c == <span class="dv">0</span>) {
    *((<span class="dt">char</span> *)a + <span class="kw">sizeof</span>(<span class="dt">int</span>)) = <span class="dv">1</span>;
    <span class="kw">if</span> (a-&gt;c != <span class="dv">0</span>)
      abort();
  }
}</code></pre>
<ul>
<li>Symbolic executors cannot report with <strong>certainty</strong> that <code>abort</code> is reachable <!-- - pointer arithmetic confuses alias analysis --></li>
<li>Dynamic-Symbolic testing need only solve <code>a-&gt;c == 0</code> to produce <strong>concrete</strong> input that will blow up! <!-- - fill gaps in symbolic reasoning with **concrete** value --></li>
</ul>
<!-- # Encoding Trees of Depth 2 -->
<!-- $\begin{aligned} -->
<!-- \cstr{C_{tree}} & \defeq & (\cvar{c}_{t0} \Rightarrow \cvar{t} = \lleaf) & \wedge & -->
<!--                            (\cvar{c}_{t1} \Rightarrow \cvar{t} = \lnode{\cvar{x}_t}{\cvar{l}_t}{\cvar{r}_t}) & \wedge & -->
<!--                            & & (\cvar{c}_{t0} & \oplus & \cvar{c}_{t1}) \\ -->
<!--                 & \wedge & (\cvar{c}_{l_t0} \Rightarrow \cvar{l}_t = \lleaf) & \wedge & -->
<!--                            (\cvar{c}_{l_t1} \Rightarrow \cvar{l}_t = \lnode{\cvar{x}_l}{\cvar{l}_l}{\cvar{r}_l}) & \wedge & -->
<!--                            (\cvar{c}_{t1} & \Rightarrow & \cvar{c}_{l_t0} & \oplus & \cvar{c}_{l_t1}) \\ -->
<!--                 & \wedge & (\cvar{c}_{r_t0} \Rightarrow \cvar{r}_t = \lleaf) & \wedge & -->
<!--                            (\cvar{c}_{r_t1} \Rightarrow \cvar{r}_t = \lnode{\cvar{x}_r}{\cvar{l}_r}{\cvar{r}_r}) & \wedge & -->
<!--                            (\cvar{c}_{t1} & \Rightarrow & \cvar{c}_{r_t0} & \oplus & \cvar{c}_{r_t1}) \\ -->
<!--                 & \wedge & (\cvar{c}_{l_l0} \Rightarrow \cvar{l}_l = \lleaf) &  & -->
<!--                             & \wedge & -->
<!--                            (\cvar{c}_{l_t1} & \Rightarrow & \cvar{c}_{l_l0}) &  & \\ -->
<!--                 & \wedge & (\cvar{c}_{r_l0} \Rightarrow \cvar{r}_l = \lleaf) &  & -->
<!--                             & \wedge & -->
<!--                            (\cvar{c}_{l_t1} & \Rightarrow & \cvar{c}_{r_l0}) &  & \\ -->
<!--                 & \wedge & (\cvar{c}_{l_r0} \Rightarrow \cvar{l}_r = \lleaf) &  & -->
<!--                             & \wedge & -->
<!--                            (\cvar{c}_{r_t1} & \Rightarrow & \cvar{c}_{l_r0}) &  & \\ -->
<!--                 & \wedge & (\cvar{c}_{r_r0} \Rightarrow \cvar{r}_r = \lleaf) &  & -->
<!--                             & \wedge & -->
<!--                            (\cvar{c}_{r_t1} & \Rightarrow & \cvar{c}_{r_r0}) &  & \\ -->
<!-- \end{aligned}$ -->
<!-- # NOTES -->
<!-- - [ ] perhaps start with demo -->
<!-- - [ ] intro is abrupt -->
<!-- - [X] monomorphic tree -->
<!-- - [ ] don't show class isntances -->
<!-- - [X] fix smallcheck/quickcheck examples -->
<!-- - [ ] preface symbolic execution better (why?) -->
<!-- - [X] keep rescale def around -->
<!-- - [X] kill questions slide -->
<!-- - [ ] maybe start with `average` -->
<!-- - [ ] more comparisons!! -->
<!-- - [X] un-demorgan refutations -->
<!-- - [X] clarify that we use a single set of constraints to represent all possible inputs -->
<!-- - [X] no sub-bullets or just bold -->
<!-- - [ ] more consistent slide titles -->
<!-- - [ ] explain all code with english -->
<!-- - [ ] RECAP: re-use black-box slides with PROBLEM section -->
<!-- # Questions -->
<!-- - do we need base types in refinements (i.e. why not assertions?) -->
<!--     - we use base types to implicitly quantify over elements of containers -->
<!--     - avoid recursive assertions, which are difficult to reason about -->
<!-- - is theory of inductive datatypes decidable? -->
<!--     - theory is decidable, but NP-complete -->
<!--     - Arrays: QF is decidable (NP-complete), w/ quals undecidable -->
<!--     - Integers: QF is NP-complete, w/ quals undecidable -->
<!--     - contrast to QF_EUF, which is polynomial -->
<!-- - studies validating small-scope hypothesis? -->
<!--     - 2003 (unpublished) study of java collections framework claims validity -->
</div>
</body>
</html>
