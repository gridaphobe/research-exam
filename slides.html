<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Eric Seidel" />
  <title>Automated Specification-Based Testing</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Automated Specification-Based Testing</h1>
  <p class="author">
Eric Seidel
  </p>
  <p class="date">eseidel@cs.ucsd.edu</p>
</div>
<div id="refinement-types" class="slide section level1">
<h1>Refinement Types</h1>
<h2 id="vt-p"><code>{v:t | p}</code></h2>
<blockquote>
<p>the set of values <code>v</code> of type <code>t</code> satisfying a predicate <code>p</code></p>
</blockquote>
</div>
<div id="simple-refinement-types" class="slide section level1">
<h1>Simple Refinement Types</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nat</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Pos</span>   <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;</span>  <span class="dv">0</span>}
<span class="kw">type</span> <span class="dt">Rng</span> <span class="dt">N</span> <span class="fu">=</span> {v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> v <span class="fu">&lt;</span> <span class="dt">N</span>}</code></pre>
</div>
<div id="compound-refinement-types" class="slide section level1">
<h1>Compound Refinement Types</h1>
<p>Describe properties of containers and function contracts by refining component types</p>
<h4 id="lists-that-contain-no-zeros">Lists that contain no zeros</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[{v<span class="fu">:</span><span class="dt">Int</span> <span class="fu">|</span> v <span class="fu">/=</span> <span class="dv">0</span>}]</code></pre>
<h4 id="functions-that-take-a-natural-number-and-increment-it-by-one">Functions that take a natural number and increment it by one</h4>
<pre class="sourceCode haskell"><code class="sourceCode haskell">x<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {v<span class="fu">:</span><span class="dt">Nat</span> <span class="fu">|</span> v <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>}</code></pre>
</div>
<div id="refinement-types-1" class="slide section level1">
<h1>Refinement Types</h1>
<ul>
<li>Traditionally used for program verification</li>
<li>We show that refinement types can also be viewed as <em>exhaustive test-suite</em></li>
<li>Allows for <em>gradual verification</em></li>
</ul>
<ol style="list-style-type: decimal">
<li>write high-level spec as refinement type</li>
<li>immediate gratification from comprehensive test-suite</li>
<li>once design has settled, add hints / inductive invariants to allow verification</li>
</ol>
</div>
<div id="target" class="slide section level1">
<h1>Target</h1>
<ul>
<li><p>generates tests from refinement types via <em>query-decode-check</em> loop</p>
<ol style="list-style-type: decimal">
<li>translate input types into SMT <strong>query</strong></li>
<li><strong>decode</strong> SMT model into concrete values</li>
<li>run function and <strong>check</strong> that result inhabits output type</li>
</ol></li>
<li><p>exhaustively checks all inputs up to a given depth-bound</p></li>
</ul>
</div>
<div id="primitive-types-query" class="slide section level1">
<h1>Primitive Types: Query</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rescale ::</span> r1<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> r2<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> s<span class="fu">:</span><span class="dt">Rng</span> r1 <span class="ot">-&gt;</span> <span class="dt">Rng</span> r2
rescale r1 r2 s <span class="fu">=</span> s <span class="fu">*</span> (r2 <span class="ot">`div`</span> r1)</code></pre>
<p>Embed primitive constraints directly in logic</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mn>0</mn></msub></mstyle><mrow><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mn>1</mn></mstyle><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mn>2</mn></mstyle><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>≤</mo><mi>s</mi><mo>&lt;</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">{\mathsf{{C_0}}} {\ \doteq\ }0 \leq {\mathit{{r1}}} {\ \land\ }0 \leq {\mathit{{r2}}} {\ \land\ }0 \leq s &lt; {\mathit{{r1}}}</annotation></semantics></math></p>
</div>
<div id="primitive-types-decode" class="slide section level1">
<h1>Primitive Types: Decode</h1>
<p>A model</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mn>1</mn></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="italic"><mi>𝑟</mi><mn>2</mn></mstyle><mo accent="false">↦</mo><mn>1</mn><mo>,</mo><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mo accent="false">↦</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[{\mathit{{r1}}} \mapsto 1, {\mathit{{r2}}} \mapsto 1, {\mathit{{s}}} \mapsto 0]</annotation></semantics></math></p>
<p>maps to a concrete test case</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span></code></pre>
</div>
<div id="primitive-types-check" class="slide section level1">
<h1>Primitive Types: Check</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rescale <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>Postcondition is</p>
<ul>
<li><code>{v:Int | v &gt;= 0 &amp;&amp; v &lt; r2}</code></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mn>0</mn><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mn>0</mn><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 \geq 0 {\ \land\ }0 &lt; 0</annotation></semantics></math></li>
</ul>
<p><strong>INVALID</strong></p>
<p><code>rescale 1 0 0</code> is a counterexample!</p>
<!-- ```haskell -->
<!-- rescale :: r1:Pos -> r2:Pos -> s:Rng r1 -> Rng r2 -->
<!-- rescale r1 r2 s = s * (r2 `div` r1) -->
<!-- ``` -->
</div>
<div id="containers" class="slide section level1">
<h1>Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Score</span> <span class="fu">=</span> <span class="dt">Rng</span> <span class="dv">100</span>

<span class="ot">average ::</span> [(<span class="dt">Pos</span>, <span class="dt">Score</span>)] <span class="ot">-&gt;</span> <span class="dt">Score</span>
average []  <span class="fu">=</span> <span class="dv">0</span>
average wxs <span class="fu">=</span> total <span class="ot">`div`</span> n
  <span class="kw">where</span>
    total   <span class="fu">=</span> sum [w <span class="fu">*</span> x <span class="fu">|</span> (w, x) <span class="ot">&lt;-</span> wxs ]
    n       <span class="fu">=</span> sum [w     <span class="fu">|</span> (w, _) <span class="ot">&lt;-</span> wxs ]</code></pre>
<p>How to encode structured data in SMT formula?</p>
</div>
<div id="choice-variables" class="slide section level1">
<h1>Choice Variables</h1>
<p>Propositional variables that guard other constraints</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">({\mathit{{c}}}_{00} \Rightarrow {\mathit{{xs}}}_0 = {\mathrm{[]}}) {\ \land\ }({\mathit{{c}}}_{01} \Rightarrow {\mathit{{xs}}}_0 = {\mathrm{{{\mathit{{x}}}_1}:{{\mathit{{xs}}}_1}}})</annotation></semantics></math></p>
<p>Force solver to choose one</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>00</mn></msub><mo>⊕</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub></mrow><annotation encoding="application/x-tex">{\mathit{{c}}}_{00} \oplus {\mathit{{c}}}_{01}</annotation></semantics></math></p>
</div>
<div id="encoding-lists-of-depth-3" class="slide section level1">
<h1>Encoding Lists of Depth 3</h1>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗅</mi><mi>𝗂</mi><mi>𝗌</mi><mi>𝗍</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>1</mn></msub><mo>:</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>00</mn></msub><mo>⊕</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>10</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>2</mn></msub><mo>:</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>10</mn></msub><mo>⊕</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>20</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>3</mn></msub><mo>:</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>3</mn></msub></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>20</mn></msub><mo>⊕</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>30</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="postfix">]</mo></mstyle><mo stretchy="false" form="postfix">)</mo></mtd><mtd><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>30</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{list}}}} &amp; {\ \doteq\ }&amp; ({\mathit{{c}}}_{00} \Rightarrow {\mathit{{xs}}}_0 = {\mathrm{[]}}) {\ \land\ }({\mathit{{c}}}_{01} \Rightarrow {\mathit{{xs}}}_0 = {\mathrm{{{\mathit{{x}}}_1}:{{\mathit{{xs}}}_1}}}) &amp; {\ \land\ }&amp;  ({\mathit{{c}}}_{00} \oplus {\mathit{{c}}}_{01}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{10} \Rightarrow {\mathit{{xs}}}_1 = {\mathrm{[]}}) {\ \land\ }({\mathit{{c}}}_{11} \Rightarrow {\mathit{{xs}}}_1 = {\mathrm{{{\mathit{{x}}}_2}:{{\mathit{{xs}}}_2}}}) &amp; {\ \land\ }&amp;  ({\mathit{{c}}}_{01} \Rightarrow {\mathit{{c}}}_{10} \oplus {\mathit{{c}}}_{11}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{20} \Rightarrow {\mathit{{xs}}}_2 = {\mathrm{[]}}) {\ \land\ }({\mathit{{c}}}_{21} \Rightarrow {\mathit{{xs}}}_2 = {\mathrm{{{\mathit{{x}}}_3}:{{\mathit{{xs}}}_3}}}) &amp; {\ \land\ }&amp;  ({\mathit{{c}}}_{11} \Rightarrow {\mathit{{c}}}_{20} \oplus {\mathit{{c}}}_{21}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{30} \Rightarrow {\mathit{{xs}}}_3 = {\mathrm{[]}}) &amp; {\ \land\ }&amp;  ({\mathit{{c}}}_{21} \Rightarrow {\mathit{{c}}}_{30}) \end{aligned}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝖽</mi><mi>𝖺</mi><mi>𝗍</mi><mi>𝖺</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>1</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>1</mn></msub><mo>,</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>1</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>2</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>2</mn></msub><mo>,</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>2</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>3</mn></msub><mo>=</mo><mstyle mathvariant="normal"><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>3</mn></msub><mo>,</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mstyle><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑤</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><mn>0</mn><mo>≤</mo><msub><mstyle mathvariant="italic"><mi>𝑠</mi></mstyle><mn>3</mn></msub><mo>&lt;</mo><mn>100</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{data}}}} &amp; {\ \doteq\ }&amp; ({\mathit{{c}}}_{01} \Rightarrow {\mathit{{x}}}_1 = {\mathrm{({{\mathit{{w}}}_1},{{\mathit{{s}}}_1})}} \ {\ \land\ }\ 0 &lt; {\mathit{{w}}}_1 \ {\ \land\ }\ 0 \leq {\mathit{{s}}}_1 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{11} \Rightarrow {\mathit{{x}}}_2 = {\mathrm{({{\mathit{{w}}}_2},{{\mathit{{s}}}_2})}} \ {\ \land\ }\ 0 &lt; {\mathit{{w}}}_2 \ {\ \land\ }\ 0 \leq {\mathit{{s}}}_2 &lt; 100) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{21} \Rightarrow {\mathit{{x}}}_3 = {\mathrm{({{\mathit{{w}}}_3},{{\mathit{{s}}}_3})}} \ {\ \land\ }\ 0 &lt; {\mathit{{w}}}_3 \ {\ \land\ }\ 0 \leq {\mathit{{s}}}_3 &lt; 100) \end{aligned}</annotation></semantics></math></p>
</div>
<div id="ordered-containers" class="slide section level1">
<h1>Ordered Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a

<span class="kw">data</span> <span class="dt">Sorted</span> a <span class="fu">=</span> []
              <span class="fu">|</span> (<span class="fu">:</span>) {<span class="ot"> h ::</span> a
                    ,<span class="ot"> t ::</span> <span class="dt">Sorted</span> {v<span class="fu">:</span>a <span class="fu">|</span> h <span class="fu">&lt;</span> v}
                    }</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗈</mi><mi>𝗋</mi><mi>𝖽</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>2</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>3</mn></msub><mspace width="0.222em"></mspace><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>1</mn></msub><mo>&lt;</mo><msub><mstyle mathvariant="italic"><mi>𝑥</mi></mstyle><mn>3</mn></msub><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{ord}}}} &amp; {\ \doteq\ }&amp; ({\mathit{{c}}}_{11} \Rightarrow {\mathit{{x}}}_1 &lt; {\mathit{{x}}}_2)  {\ \land\ }({\mathit{{c}}}_{21} \Rightarrow {\mathit{{x}}}_2 &lt; {\mathit{{x}}}_3\ {\ \land\ }\ {\mathit{{x}}}_1 &lt; {\mathit{{x}}}_3) \end{aligned}</annotation></semantics></math></p>
</div>
<div id="structured-containers" class="slide section level1">
<h1>Structured Containers</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">best ::</span> k<span class="fu">:</span><span class="dt">Nat</span> <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">&lt;=</span> len v} 
     <span class="ot">-&gt;</span> {v<span class="fu">:</span>[<span class="dt">Score</span>] <span class="fu">|</span> k <span class="fu">=</span> len v}
best k xs <span class="fu">=</span> take k <span class="fu">$</span> reverse <span class="fu">$</span> sort xs

measure<span class="ot"> len ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Nat</span>
len []      <span class="fu">=</span> <span class="dv">0</span>
len (x<span class="fu">:</span>xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> len xs</code></pre>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mstyle mathvariant="sans-serif"><msub><mi>𝖢</mi><mrow><mi>𝗌</mi><mi>𝗂</mi><mi>𝗓</mi><mi>𝖾</mi></mrow></msub></mstyle></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>≐</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>00</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>01</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>0</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>10</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>11</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>1</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>20</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>21</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>2</mn></msub></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>3</mn></msub></mrow><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mspace width="0.222em"></mspace><mo>∧</mo><mspace width="0.222em"></mspace></mtd><mtd><mo stretchy="false" form="prefix">(</mo><msub><mstyle mathvariant="italic"><mi>𝑐</mi></mstyle><mn>30</mn></msub><mo accent="false">⇒</mo><mrow><mstyle mathvariant="sans-serif"><mi>𝗅</mi><mi>𝖾</mi><mi>𝗇</mi></mstyle><mspace width="0.222em"></mspace><msub><mstyle mathvariant="italic"><mi>𝑥</mi><mi>𝑠</mi></mstyle><mn>3</mn></msub></mrow><mo>=</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} {\mathsf{{C_{size}}}} &amp; {\ \doteq\ }&amp; ({\mathit{{c}}}_{00} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{0}}} = 0) {\ \land\ }({\mathit{{c}}}_{01} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{0}}} = 1 + {{\mathsf{{len}}}\ {{\mathit{{xs}}}_1}}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{10} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{1}}} = 0) {\ \land\ }({\mathit{{c}}}_{11} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{1}}} = 1 + {{\mathsf{{len}}}\ {{\mathit{{xs}}}_2}}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{20} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{2}}} = 0) {\ \land\ }({\mathit{{c}}}_{21} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{2}}} = 1 + {{\mathsf{{len}}}\ {{\mathit{{xs}}}_3}}) \\  &amp; {\ \land\ }&amp; ({\mathit{{c}}}_{30} \Rightarrow {{\mathsf{{len}}}\ {{\mathit{{xs}}}_{3}}} = 0) \end{aligned}</annotation></semantics></math></p>
</div>
<div id="evaluation" class="slide section level1">
<h1>Evaluation</h1>
<ul>
<li>compared Target against QuickCheck, SmallCheck, Lazy SmallCheck
<ul>
<li><code>Data.Map</code>, <code>RBTree</code>, <code>XMonad.StackSet</code></li>
<li>no custom generators</li>
</ul></li>
<li><code>Data.Map</code>
<ul>
<li>checked balancing and ordering invariants</li>
</ul></li>
<li><code>RBTree</code>
<ul>
<li>checked red-black and ordering invariants</li>
</ul></li>
<li><code>XMonad.StackSet</code>
<ul>
<li>checked uniqueness of windows</li>
</ul></li>
</ul>
</div>
<div id="evaluation-1" class="slide section level1">
<h1>Evaluation</h1>
<p><img height=500px src="benchmarks.png"></p>
</div>
<div id="takeaway" class="slide section level1">
<h1>Takeaway</h1>
<ul>
<li>Target can explore larger inputs than Lazy SmallCheck</li>
<li>Target specs are amenable to future formal verification</li>
<li>QuickCheck <strong>requires</strong> custom generators for functions with complex preconditions</li>
</ul>
</div>
</body>
</html>
